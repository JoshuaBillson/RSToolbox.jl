<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spectral Analysis · RemoteSensingToolbox.jl</title><meta name="title" content="Spectral Analysis · RemoteSensingToolbox.jl"/><meta property="og:title" content="Spectral Analysis · RemoteSensingToolbox.jl"/><meta property="twitter:title" content="Spectral Analysis · RemoteSensingToolbox.jl"/><meta name="description" content="Documentation for RemoteSensingToolbox.jl."/><meta property="og:description" content="Documentation for RemoteSensingToolbox.jl."/><meta property="twitter:description" content="Documentation for RemoteSensingToolbox.jl."/><meta property="og:url" content="https://JoshuaBillson.github.io/RemoteSensingToolbox.jl/spectral_example/"/><meta property="twitter:url" content="https://JoshuaBillson.github.io/RemoteSensingToolbox.jl/spectral_example/"/><link rel="canonical" href="https://JoshuaBillson.github.io/RemoteSensingToolbox.jl/spectral_example/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RemoteSensingToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../pansharpening/">Pansharpening</a></li><li><a class="tocitem" href="../pca_example/">Principal Component Analysis</a></li><li class="is-active"><a class="tocitem" href>Spectral Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Spectral Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spectral Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoshuaBillson/RemoteSensingToolbox.jl/blob/main/docs/src/spectral_example.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Spectral-Analysis"><a class="docs-heading-anchor" href="#Spectral-Analysis">Spectral Analysis</a><a id="Spectral-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-Analysis" title="Permalink"></a></h1><p>Land cover classification is a common application of remotely sensed imagery. Such a task involves  assigning a discrete label to each pixel in an image denoting the type of land contained within it. For example, we may wish to classify each pixel as either water or land. This is typically  accomplished by observing the unique spectral signatures produced by each material. <code>RemoteSensingToolbox</code> provides a number of methods for both extracting and visualizing signatures from a labelled image.</p><p>Our first step is to read the relevant bands from disk and convert the DNs (Digital Numbers) to  reflectance. Reflectance is a standardized unit of measurement defined over the interval [0, 1], which denotes the fraction of light reflected by the observed surface. A reflectance of 0.0 indicates that no light was reflected at all, whereas a reflectance of 1.0 tells us that 100% was reflected.  Fortunately, each <code>AbstractSatellite</code> contains the necessary information for this conversion.</p><pre><code class="language-julia hljs">using RemoteSensingToolbox, Rasters, Statistics, DataFrames, Shapefile

# Read Landsat, Sentinel, and DESIS Bands
landsat_src = Landsat8(&quot;data/LC08_L2SP_043024_20200802_20200914_02_T1&quot;)
sentinel_src = Sentinel2{60}(&quot;data/S2B_MSIL2A_20200804T183919_N0214_R070_T11UPT_20200804T230343&quot;)
desis_src = DESIS(&quot;data/DESIS-HSI-L2A-DT0485529167_001-20220712T223540-V0220&quot;)
landsat = RasterStack(landsat_src, lazy=true)
sentinel = RasterStack(sentinel_src, lazy=true)
desis = Raster(desis_src, :Bands, lazy=true)

# Convert DNs to Surface Reflectance
landsat_sr = decode(Landsat8, landsat)
sentinel_sr = decode(Sentinel2{60}, sentinel)
desis_sr = decode(DESIS, desis)</code></pre><p>Once we have our imagery, we need to acquire some labelled regions from which to extract the spectral signatures.  This is typically accomplished with a shapefile consisting of polygons labelled with each type of land cover.</p><pre><code class="language-julia hljs">shp = Shapefile.Table(&quot;data/landcover/landcover.shp&quot;) |&gt; DataFrame</code></pre><p>Examining the shapefile gives us some insight into how its contents are structured. As we can see, the regions of interest are stored as <code>Polygon</code> objects under the <code>:geometry</code> column, while land cover labels are under both <code>:MC_name</code> and <code>:C_name</code>. In this case, <code>:MC_name</code> defines the macro class while <code>:C_name</code> defines the specific class. For example, both &quot;Trees&quot; and &quot;Vegetation&quot; belong to the &quot;Vegetation&quot; macro class.</p><pre><code class="nohighlight hljs">8×7 DataFrame
 Row │ geometry            fid      MC_ID  MC_name     C_ID   C_name      SCP_UID                   
     │ Polygon             Missing  Int64  String      Int64  String      String                    
─────┼──────────────────────────────────────────────────────────────────────────────────────────────
   1 │ Polygon(38 Points)  missing      1  Built Up        1  Built Up    20230527_122212594060_314
   2 │ Polygon(31 Points)  missing      1  Built Up        2  Road        20230527_122301732906_304
   3 │ Polygon(57 Points)  missing      2  Vegetation      4  Trees       20230527_123221462871_572
   4 │ Polygon(5 Points)   missing      3  Bare Earth      5  Hail Scar   20230527_123631491671_937
   5 │ Polygon(7 Points)   missing      3  Bare Earth      6  Bare Earth  20230527_123727873290_779
   6 │ Polygon(7 Points)   missing      4  Water           7  Lake        20230527_123931189139_867
   7 │ Polygon(5 Points)   missing      3  Bare Earth      6  Bare Earth  20230527_125120033074_286
   8 │ Polygon(5 Points)   missing      2  Vegetation      3  Vegetation  20230527_122832068862_308</code></pre><p>We can call <code>extract_signatures</code> to retrieve the spectral signatures located within each polygon along with their associated labels. An optional aggregation method can be supplied as the first argument, which will be used to summarize signatures belonging to the same label. Some common examples are <code>mean</code>, <code>median</code>, <code>maximum</code>,  and <code>minimum</code>. If no method is provided, <code>extract_signatures</code> will return all signatures and their labels.</p><pre><code class="language-julia hljs">sigs = extract_signatures(mean, landsat_sr, shp, :MC_name) |&gt; DataFrame</code></pre><pre><code class="nohighlight hljs">4×8 DataFrame
 Row │ label       B1          B2          B3         B4          B5        B6          B7         
     │ String      Float32     Float32     Float32    Float32     Float32   Float32     Float32    
─────┼─────────────────────────────────────────────────────────────────────────────────────────────
   1 │ Bare Earth  0.0566671   0.0871629   0.145427   0.185996    0.401831  0.317775    0.184228
   2 │ Built Up    0.0506521   0.0679052   0.113027   0.120046    0.254274  0.236384    0.18103
   3 │ Water       0.00137886  0.00423271  0.0135606  0.00652965  0.031825  0.00709321  0.00381732
   4 │ Vegetation  0.00699952  0.0166328   0.0716218  0.0422207   0.462393  0.10416     0.0438761</code></pre><p>While <code>extract_signatures</code> can be a good first step for further analysis or training classification models, we are  also often interested in visualizing the signatures associated with each land cover type. To do so, we can import <code>CairoMakie</code>, which is extended by <code>RemoteSensingToolbox</code> to provide signature plotting. In order to display the appropriate wavelength for each band, <code>plot_signatures</code> expects either a vector of band-wavelength pairs or an <code>AbstractSatellite</code> type as the first argument.</p><pre><code class="language-julia hljs">import CairoMakie

plot_signatures(Landsat8, landsat_sigs)</code></pre><p><img src="../figures/landsat_sigs_wong.png" alt/></p><p>To override the default color scheme, we can provide an optional <code>colors</code> argument. Refer to  <a href="https://juliagraphics.github.io/Colors.jl/stable/namedcolors/">Colors.jl</a> for a complete list of all named colors.</p><pre><code class="language-julia hljs">colors = [:saddlebrown, :orange, :navy, :green]
fig = plot_signatures(Landsat8, landsat_sigs, colors=colors)</code></pre><p><img src="../figures/landsat_sigs_custom.png" alt/></p><p>Sometimes we want to have more control over our plots than what is provided by <code>plot_signatures</code>. To accommodate this need, we provide the <code>plot_signatures!</code> method, which directly modifies a provided <code>Makie.Axis</code> object. In the following example, we will plot the same signatures produced by three different sensors, each of which passed over our study area within a period of four days.</p><pre><code class="language-julia hljs"># Create Figure
fig = CairoMakie.Figure(resolution=(1000, 800))

# Create Axes
ax1 = CairoMakie.Axis(fig[1,1], title=&quot;Landsat 8&quot;, xticksvisible=false, xticklabelsvisible=false)
ax2 = CairoMakie.Axis(fig[2,1], title=&quot;Sentinel 2&quot;, ylabel=&quot;Reflectance&quot;, ylabelfont=:bold, xticksvisible=false, xticklabelsvisible=false)
ax3 = CairoMakie.Axis(fig[3,1], title=&quot;DESIS&quot;, xlabel=&quot;Wavelength (nm)&quot;, xlabelfont=:bold)

# Plot Signatures
axs = (ax1, ax2, ax3)
sensors = (Landsat8, Sentinel2{60}, DESIS)
rasters = (landsat_sr, sentinel_sr, desis_sr)
for (sensor, raster, ax) in zip(sensors, rasters, axs)
    sigs = extract_signatures(mean, raster, shp, :MC_name)
    plot_signatures!(ax, sensor, sigs; colors=colors)
    CairoMakie.xlims!(ax, 400, 1000)
end

# Add Legend
CairoMakie.Legend(fig[1:3,2], first(axs), &quot;Classification&quot;)</code></pre><p><img src="../figures/multisensor_sigs.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pca_example/">« Principal Component Analysis</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 16 January 2024 01:26">Tuesday 16 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"RemoteSensingToolbox provides a number of utilities for visualizing, manipulating, and interpreting remotely sensed imagery. First, lets load the imagery we want to work with. We're using Landsat 8 imagery in this example, so we'll pass the Landsat8 type to read_bands so it knows how to parse the relevant files from the provided directory. Landsat8 is an instance of AbstractBandset, which is the supertype responsible for allowing many methods within RemoteSensingToolbox to infer sensor-specific information by exploiting Julia's multiple dispatch system.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using RemoteSensingToolbox, Rasters\n\nsrc = Landsat8(\"LC08_L2SP_043024_20200802_20200914_02_T1\")\nstack = RasterStack(src, lazy=true)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now let's visualize our data to see what we're working with. This is where the power of AbstractBandset can first be demonstrated. To view a true color composite of the data, we need to know the bands corresponding to red, green, and blue. However, it would be tedious to memorize and manually specify this information whenever we want to call a method which relies on a specific combination of bands. Fortunately, all AbstractBandset types know this information implicitly, so all we need to do is pass in Landsat8 as a parameter to TrueColor.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"visualize(TrueColor{Landsat8}, stack; upper=0.90)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"You may have noticed that we provided an additional argument upper to the visualize method. This parameter controls the upper quantile to be used when performing histogram stretching to make the imagery interpretable to humans. This parameter is set to 0.98 by default, but because our scene contains a significant number of bright clouds, we need to lower it to prevent the image from appearing too dark. We can remove these clouds by first loading the Quality Assurance (QA) mask that came with our landsat product and then calling mask_pixels.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"# Mask Clouds\ncloud_mask = Raster(src, :clouds)\nshadow_mask = Raster(src, :cloud_shadow)\nraster_mask = .!(boolmask(cloud_mask) .|| boolmask(shadow_mask))\nmasked = mask(stack, with=raster_mask)\n\n# Visualize in True Color\nvisualize(TrueColor{Landsat8}, masked)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now let's try to visualize some other band combinations. The Agriculture band comination is commonly used to distinguish regions with healthy vegetation, which appear as various shades of green.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"visualize(Agriculture{Landsat8}, stack; upper=0.90)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"We'll finish this example by demonstrating how to compute land cover indices with any AbstractBandset type. The Modified Normalized Difference Water Index (MNDWI) is used to help distinguish water from land. Here, we visualize both the true color representation and the corresponding MNDWI index.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"# Calculate Indices\nindices = (mndwi=mndwi(src), ndvi=ndvi(src), ndmi=ndmi(src))\n\n# Extract Region of Interest\nstack = merge(stack, indices)\nroi = @view stack[X(5800:6800), Y(2200:3200)]\n\n# Visualize\ntrue_color = visualize(TrueColor{Landsat8}, roi; upper=0.998)\nindex_imgs = [visualize(roi[i]) for i in (:mndwi, :ndvi, :ndmi)]\nmosaicview(true_color, index_imgs...; npad=10, fillvalue=0.0, ncol=2, rowmajor=true)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"spectral_example/#Spectral-Analysis","page":"Spectral Analysis","title":"Spectral Analysis","text":"","category":"section"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"A common application of remotely sensed imagery is land cover classification. One method to accomplish this is to analyze the spectral signatures produced by different types of cover. RemoteSensingToolbox provides a number of functions for extracting and visualyzing spectral signatures organized by their associated lan cover.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"The first step in our analysis is to load our remotely sensed data and convert the DNs (Digital Numbers) to reflectances. Reflectance is a standardized unit of measurement defined over the interval [0, 1] which denotes the fraction of light that is reflected by the observed surface. A reflectance of 0.0 indicates that no light was reflected whereas a reflectance of 1.0 indicates that 100% of light was reflected.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"using RemoteSensingToolbox, DataFrames, Shapefile, CairoMakie\nusing Pipe: @pipe\n\nlandsat = @pipe read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"Next, we need to load a shapefile which defines some regions containing each type of land cover that we're interested in.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"shp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"Examining the shapefile gives us some idea of how its contents are structured. As we can see, the regions of interest are stored as Polygon objects under the :geometry column, while the land cover types are under :MC_name and :C_name. The :MC_name column defines the macroclass, which in our case are built up land, vegetation, bare earth, and water. The :C_name column defines the specific class to which some land cover belongs. For example, both \"Trees\" and \"Vegetation\" belong to the \"Vegetation\" macroclass.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"8×7 DataFrame\n Row │ geometry            fid      MC_ID  MC_name     C_ID   C_name      SCP_UID                   \n     │ Polygon             Missing  Int64  String      Int64  String      String                    \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Polygon(38 Points)  missing      1  Built Up        1  Built Up    20230527_122212594060_314\n   2 │ Polygon(31 Points)  missing      1  Built Up        2  Road        20230527_122301732906_304\n   3 │ Polygon(7 Points)   missing      2  Vegetation      3  Vegetation  20230527_122832068862_302\n   4 │ Polygon(57 Points)  missing      2  Vegetation      4  Trees       20230527_123221462871_572\n   5 │ Polygon(5 Points)   missing      3  Bare Earth      5  Hail Scar   20230527_123631491671_937\n   6 │ Polygon(7 Points)   missing      3  Bare Earth      6  Bare Earth  20230527_123727873290_779\n   7 │ Polygon(7 Points)   missing      4  Water           7  Lake        20230527_123931189139_867\n   8 │ Polygon(5 Points)   missing      3  Bare Earth      6  Bare Earth  20230527_125120033074_286","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"We can extract the signatures inside each polygon with extract_signatures. This method returns a RasterTable, which is a special type optimized for extracting tablular data from a raster data source. Because RasterTable implements the Tables.jl interface, it can be directly sunk into other table constructors, such as  DataFrames, and is also compatible with external libraries like TableOperations.jl.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"sigs = extract_signatures(landsat, shp, :C_name) |> DataFrame","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"1925×8 DataFrame\n  Row │ B1         B2         B3        B4        B5        B6        B7        label     \n      │ Float32    Float32    Float32   Float32   Float32   Float32   Float32   String    \n──────┼───────────────────────────────────────────────────────────────────────────────────\n    1 │ 0.057235   0.10547    0.188932  0.24847   0.513405  0.315323  0.166107  Hail Scar\n    2 │ 0.0574     0.105415   0.188712  0.24946   0.513735  0.317908  0.167593  Hail Scar\n    3 │ 0.0584175  0.107175   0.19182   0.253887  0.515577  0.319585  0.168087  Hail Scar\n    4 │ 0.0583625  0.10723    0.190995  0.253393  0.514615  0.317715  0.167097  Hail Scar\n    5 │ 0.05806    0.10745    0.189895  0.250368  0.50774   0.315048  0.165475  Hail Scar\n    6 │ 0.05553    0.102885   0.184175  0.243272  0.498417  0.307485  0.160938  Hail Scar\n    7 │ 0.05267    0.0983475  0.176585  0.230073  0.48783   0.29159   0.153292  Hail Scar\n  ⋮   │     ⋮          ⋮         ⋮         ⋮         ⋮         ⋮         ⋮          ⋮\n 1919 │ 0.0320725  0.05993    0.11306   0.127415  0.272258  0.27322   0.220777  Built Up\n 1920 │ 0.100575   0.127168   0.199218  0.23164   0.285677  0.323985  0.258645  Built Up\n 1921 │ 0.077145   0.112097   0.17081   0.19677   0.25705   0.320877  0.28015   Built Up\n 1922 │ 0.10712    0.136765   0.19666   0.225068  0.268655  0.33284   0.302288  Built Up\n 1923 │ 0.0856425  0.123235   0.185853  0.211675  0.273     0.373623  0.351072  Built Up\n 1924 │ 0.088145   0.119578   0.17059   0.204442  0.27487   0.355857  0.325553  Built Up\n 1925 │ 0.0518725  0.0816275  0.148673  0.15189   0.28774   0.309218  0.29786   Built Up\n                                                                         1911 rows omitted","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"While extract_signatures can be a good first step for further statistical analysis or training classification modelsFinally, we are also often interested in visualizing the spectral signatures associated with each land cover type. To to do, we can call plot_signatures, which plots each signature as a CairoMakie line graph.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"plot_signatures(Landsat8, landsat, shp, :C_name)","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"(Image: )","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"We see that we've plotted the signatures for each land cover type in shp. However, we may wish to override the default colors. Fortunately, plot_signatures accepts an optional argument allowing us to specify any colors that we wish.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"plot_signatures(Landsat8, landsat, shp, :C_name; colors=cgrad(:tab10))","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"(Image: )","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"The plot_signatures! method is nearly identical to plot_signatures, but it expects a Makie.Axis object as its first argument onto which the signatures will be drawn (hence the exclamation). This allows us to create more sophisticated plots than are supported by plot_signatures. We will demonstrate this capability by plotting the same signatures for three different sensors, each of which passed over our study area within a period of four days. ","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"# Load Sentinel and DESIS\nsentinel = @pipe read_bands(Sentinel2, \"data/T11UPT_20200804T183919/R60m/\") |> dn_to_reflectance(Sentinel2, _)\ndesis = @pipe read_bands(DESIS, \"data/DESIS-HSI-L2A-DT0884573241_001-20200601T234520-V0210\") |> dn_to_reflectance(DESIS, _)\nsensors = [landsat, sentinel, desis]\n\n# Create Figure\nfig = Figure(resolution=(1000, 800))\n\n# Create Axes\nax1 = Axis(fig[1,1], title=\"Landsat 8\", xticksvisible=false, xticklabelsvisible=false)\nax2 = Axis(fig[2,1], title=\"Sentinel 2\", ylabel=\"Reflectance\", ylabelfont=:bold, xticksvisible=false, xticklabelsvisible=false)\nax3 = Axis(fig[3,1], title=\"DESIS\", xlabel=\"Wavelength (nm)\", xlabelfont=:bold)\naxs = [ax1, ax2, ax3]\n\n# Plot Signatures\ncolors = cgrad([:saddlebrown, :navy, :orange, :green], 4, categorical=true)\nfor (bandset, sensor, ax) in zip((Landsat8, Sentinel2, DESIS), sensors, axs)\n   plot_signatures!(ax, bandset, sensor, shp, :MC_name; colors=colors)\n   xlims!(ax, 400, 1000)\nend\n\n# Add Legend\nLegend(fig[1:3,2], first(axs), \"Classification\")","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"pca_example/#Principal-Component-Analysis","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"","category":"section"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Remotely sensed imagery typically consists of anywhere from five to several hundred spectral bands. These bands are often highly correlated because they occupy similar spectral regions. ","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"PCA is used in remote sensing to:","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Create a smaller dataset from multiple bands, while retaining as much of the original spectral information as possible. The new image will consist of several uncorrelated PC bands.\nReveal complex relationships among spectral features.\nDetermine which characteristics are prevalent in most of the bands, and those that are specific to only a few.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Our first step is to load and visualize our initial image.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"using RemoteSensingToolbox, Rasters\nusing Pipe: @pipe\n\nsentinel = read_bands(Sentinel2, \"data/T11UPT_20200804T183919/R60m/\")\nroi = @view sentinel[Rasters.X(900:1799), Rasters.Y(1:900)]\nvisualize(roi, TrueColor{Sentinel2}; upper=0.99)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Next, we'll fit a PCA transformation to our image. The reason that we make fitting and transformation seperate is so that the procedure can be repeated and reversed. We'll try keeping all of the components at first so we can get a sense of how many we'll need to retain. ","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"pca = fit_pca(sentinel, method=:cov)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"PCA(dimensions=11) \n\nProjection Matrix:\n11×11 Matrix{Float32}:\n -0.026   -0.2068  -0.359    0.312   -0.0955  -0.4791   0.2245  -0.6117   0.1862  -0.1494   0.1005\n -0.0361  -0.2354  -0.3739   0.1417  -0.0495  -0.1544   0.3841   0.3908  -0.3467   0.2438  -0.5265\n -0.0775  -0.2406  -0.3554  -0.1492   0.0607   0.0575   0.0611   0.2326  -0.4335  -0.2812   0.6751\n -0.0396  -0.3231  -0.321   -0.0301  -0.048    0.4006   0.1103   0.1691   0.6681   0.3318   0.1738\n -0.1194  -0.2914  -0.2233  -0.3824   0.3987   0.3538  -0.1552  -0.388   -0.0944  -0.2647  -0.4087\n -0.3925   0.0354  -0.0791  -0.5717   0.1024  -0.5641  -0.2124   0.0649   0.1101   0.3449   0.0496\n -0.4949   0.1513  -0.0179  -0.1062  -0.4124   0.0178   0.1554   0.231    0.257   -0.6108  -0.1833\n -0.5257   0.084   -0.0977   0.6026   0.4321   0.0232  -0.3684   0.1418   0.0193   0.0173   0.0145\n -0.155   -0.549    0.63     0.0248   0.3084  -0.1466   0.361    0.095    0.0889  -0.0983   0.0592\n -0.0695  -0.5511   0.1381   0.1059  -0.5562   0.0011  -0.5628  -0.0342  -0.1565   0.0709  -0.0666\n -0.5216   0.1354   0.1415  -0.0111  -0.2273   0.3423   0.3317  -0.3898  -0.3017   0.39     0.1247\n\nImportance of Components:\n  Cumulative Variance: 0.76  0.9679  0.989  0.9938  0.9968  0.9984  0.9991  0.9995  0.9998  ...  1.0\n  Explained Variance: 0.76  0.2078  0.0212  0.0047  0.0031  0.0016  0.0007  0.0004  0.0002  ...  0.0001","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"If we look at the cumulative variance, we see that we only need to retain the first three principal components to account for 98.9% of the variance in our data. Knowing this, we'll perform a forward rotation with forward_pca, specifying that we want to keep only the first three components.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"transformed = forward_pca(pca, roi, 3)\nr, g, b = [view(transformed, Rasters.Band(i)) for i in 1:3]\nvisualize(r, g, b; upper=0.99)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Each band in the transformed image corresponds to a linear combination of multiple bands from the original image. Thus, the bands no longer relate to wavelengths of light, but instead capture different features from the underlying spectral signatures. In the above visualization, we can see that water is highlighted in yellow, vegetation is green, and built-up land produces hues of bright red. ","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"We may also wish to reverse the transformation in order to recover an approximation of the original image. We can do this with the inverse_pca method, which will return a RasterStack with the same layers as the original image, assuming that it was itself a RasterStack. This makes the recovered image compatible with methods that dispatch on AbstractBandset types, such as visualize.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"recovered = inverse_pca(pca, transformed)\nvisualize(recovered, TrueColor{Sentinel2}; upper=0.99)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"We can see that the color of the recovered image is indeed similar, but not identical to that of the original. Had we elected to retain all 11 components, we would find the two to be identical (minus some floating point error).","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"#RemoteSensingToolbox","page":"Home","title":"RemoteSensingToolbox","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RemoteSensingToolbox is a pure Julia package built on top of Rasters.jl for visualizing, analyzing, and manipulating remotely sensed imagery. Most methods expect either an AbstractRaster or AbstractRasterStack as input and return the same. The most important exception to this rule is visualize, which returns an Array of either Gray or RGB pixels, depending on whether the visualization is intended to be in color or grayscale. The result is that the output of visualize will be automatically displayed inside Pluto. ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RemoteSensingToolbox is a work in progress. This means that new features are being added and existing features are subject to change. To contribute to this project, please create an issue on GitHub or open a pull request.  A summary of both existing and future features are provided below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Feature Description Implemented\nVisualization Visualize images with various band composites Yes\nLand Cover Indices Calculate indices such as MNDWI and NDVI Yes\nQA and SCL Decoding Decode Quality Assurance and Scene Classification masks Yes\nPixel Masking Mask pixels to remove objects such as clouds or shadows Yes\nPCA Perform PCA analysis, transformation, and reconstruction Yes\nMNF Minimum Noise Fraction transformation and reconstruction Yes\nSignature Analysis Visualize spectral signatures for different land cover types Yes\nLand Cover Classification Exposes an MLJ interface for classifying land cover types No\nEndmember Extraction Extract spectral endmembers from an image No\nSpectral Unmixing Perform spectral unmixing under a given endmember library No","category":"page"},{"location":"#Rasters.jl","page":"Home","title":"Rasters.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RemoteSensingToolbox is intended to be used in conjunction with the wider Julia ecosystem and as such, seeks to avoid duplicating functinalities provided by other packages. As the majority of methods accept and return AbstractRaster or AbstractRasterStack objects, users should be able to call methods from Rasters.jl at any point in the processing pipeline. A summary of common functionalities offered by Rasters is provided below: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Description\nmosaic Join rasters covering different extents into a single array or file.\ncrop Shrink objects to specific dimension sizes or the extent of another object.\nextend Extend objects to specific dimension sizes or the extent of another object.\ntrim Trims areas of missing values for arrays and across stack layers.\nresample Resample data to a different size and projection, or snap to another object.\nmask Mask a raster by a polygon or the non-missing values of another Raster.\nreplace_missing Replace all missing values in a raster and update missingval.\nextract Extract raster values from points or geometries.\nzonal Calculate zonal statistics for a raster masked by geometries.","category":"page"},{"location":"#Satellites","page":"Home","title":"Satellites","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AbstractSatellites are Julia types that encode sensor-specific information needed for many methods in RemoteSensingToolbox to work without requiring tedious details from the end user. One of their primary uses is to allow various layers to be requested  by name. For example, if we have bound the variable src to an instance of Landsat8, then we can load a cloud mask from the  included QA file by calling Raster(src, :clouds). Each AbstractSatellite also includes information about how to convert digital numbers into reflectance or temperature, the wavelengths associated with each band, and how to parse metadata from a scene's name.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbstractSatellite\nLandsat7\nLandsat8\nLandsat9\nSentinel2\nDESIS\nbands\nlayers\nwavelengths\nwavelength\nblue_band\ngreen_band\nred_band\nnir_band\nswir1_band\nswir2_band\ndn_scale\ndn_offset\ndecode\nencode\nRasters.Raster\nRasters.RasterStack","category":"page"},{"location":"#SatelliteDataSources.AbstractSatellite","page":"Home","title":"SatelliteDataSources.AbstractSatellite","text":"The super-type of all satellites. \n\nSub-types must implement the AbstractSatellite interface.\n\n\n\n\n\n","category":"type"},{"location":"#SatelliteDataSources.Landsat7","page":"Home","title":"SatelliteDataSources.Landsat7","text":"Implements the AbstractSatellite interface for Landsat 7.\n\nSupported Bands: :B1, :B2, :B3, :B4, :B5, :B7, :thermal, :panchromatic\n\nSupported Colors: :blue, :green, :red, :nir, :swir1, :swir2\n\nSupported Masks: :dilated_clouds, :clouds, :cloud_shadow, :snow, :water\n\n\n\n\n\n","category":"type"},{"location":"#SatelliteDataSources.Landsat8","page":"Home","title":"SatelliteDataSources.Landsat8","text":"Implements the AbstractSatellite interface for Landsat 8.\n\nSupported Bands: :B1, :B2, :B3, :B4, :B5, :B6, :B7, :thermal1, :thermal2, :panchromatic\n\nSupported Colors: :blue, :green, :red, :nir, :swir1, :swir2\n\nSupported Masks: :dilated_clouds, :clouds, :cloud_shadow, :snow, :water\n\n\n\n\n\n","category":"type"},{"location":"#SatelliteDataSources.Landsat9","page":"Home","title":"SatelliteDataSources.Landsat9","text":"Implements the AbstractSatellite interface for Landsat 9.\n\nSupported Layers: :B1, :B2, :B3, :B4, :B5, :B6, :B7, :thermal1, :thermal2, :panchromatic\n\nSupported Colors: :blue, :green, :red, :nir, :swir1, :swir2\n\nSupported Masks: :dilated_clouds, :clouds, :cloud_shadow, :snow, :water\n\n\n\n\n\n","category":"type"},{"location":"#SatelliteDataSources.Sentinel2","page":"Home","title":"SatelliteDataSources.Sentinel2","text":"Implements the AbstractSatellite interface for Sentinel 2.\n\nThe user must specify a resolution of 10, 20, or 60 meters.\n\nSupported Bands (10m): :B02, :B03, :B04, :B08\n\nSupported Bands (20m): :B02, :B03, :B04, :B05, :B06, :B07, :B8A, :B11, :B12\n\nSupported Bands (60m): :B01, :B02, :B03, :B04, :B05, :B06, :B07, :B8A, :B09, :B11, :B12\n\nSupported Colors (10m): :blue, :green, :red, :nir  \n\nSupported Colors (20m and 60m): :blue, :green, :red, :nir, :swir1, :swir2  \n\nSupported Masks (20m and 60m): :cloud_shadow, :clouds_med, :clouds_high, :cirrus, :vegetation, :soil, :water, :snow  \n\n\n\n\n\n","category":"type"},{"location":"#SatelliteDataSources.DESIS","page":"Home","title":"SatelliteDataSources.DESIS","text":"Implements the AbstractSatellite interface for DESIS.\n\nSupported Bands: :Bands, :Band_30, :Band_65, :Band_100, :Band_175\n\nSupported Colors: :blue, :green, :red, :nir\n\nSupported Masks: :clouds, :shadow, :haze, :snow, :land, :water\n\n\n\n\n\n","category":"type"},{"location":"#SatelliteDataSources.bands","page":"Home","title":"SatelliteDataSources.bands","text":"bands(::Type{AbstractSatellite})\n\nReturn the band names in order from shortest to longest wavelength.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.layers","page":"Home","title":"SatelliteDataSources.layers","text":"layers(::Type{AbstractSatellite})\nlayers(x::AbstractSatellite)\n\nReturn the names of all layers available for the given sensor.\n\nExample\n\n# Get all Available Layers for Landsat 8\nlandsat_layers = layers(Landsat8)\n\n# Get all Available Layers for a Specific Scene\nsrc = Landsat8(\"LC08_L2SP_043024_20200802_20200914_02_T1\")\navailable_layers = layers(src)\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.wavelengths","page":"Home","title":"SatelliteDataSources.wavelengths","text":"wavelengths(::Type{AbstractSatellite})\n\nReturn the central wavelengths for all bands in order from shortest to longest.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.wavelength","page":"Home","title":"SatelliteDataSources.wavelength","text":"wavelength(::Type{AbstractSatellite}, band::Symbol)\n\nReturn the central wavelength for the corresponding band.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.blue_band","page":"Home","title":"SatelliteDataSources.blue_band","text":"blue_band(::Type{AbstractSatellite})\n\nReturn the blue band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.green_band","page":"Home","title":"SatelliteDataSources.green_band","text":"green_band(::Type{AbstractSatellite})\n\nReturn the green band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.red_band","page":"Home","title":"SatelliteDataSources.red_band","text":"red_band(::Type{AbstractSatellite})\n\nReturn the red band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.nir_band","page":"Home","title":"SatelliteDataSources.nir_band","text":"nir_band(::Type{AbstractSatellite})\n\nReturn the nir band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.swir1_band","page":"Home","title":"SatelliteDataSources.swir1_band","text":"swir1_band(::Type{AbstractSatellite})\n\nReturn the swir1 band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.swir2_band","page":"Home","title":"SatelliteDataSources.swir2_band","text":"swir2_band(::Type{AbstractSatellite})\n\nReturn the swir2 band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.dn_scale","page":"Home","title":"SatelliteDataSources.dn_scale","text":"dn_scale(::Type{AbstractSatellite}, layer::Symbol)\n\nReturn the scale factor applied to digital numbers.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.dn_offset","page":"Home","title":"SatelliteDataSources.dn_offset","text":"dn_offset(::Type{AbstractSatellite}, layer::Symbol)\n\nReturn the offset factor applied to digital numbers.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.decode","page":"Home","title":"SatelliteDataSources.decode","text":"decode(s::Type{AbstractSatellite}, raster::Rasters.AbstractRaster)\ndecode(s::Type{AbstractSatellite}, raster::Rasters.AbstractRasterStack)\n\nDecode the Digital Number (DN) values in the given raster(s). Typically, the decoded values will be in either reflectance (visual bands) or Kelvin (thermal bands).\n\nParameters\n\ns: The AbstractSatellite that produced the raster(s) in question.\nraster: Either a Rasters.Raster or Rasters.RasterStack to be decoded.\n\n\n\n\n\n","category":"function"},{"location":"#SatelliteDataSources.encode","page":"Home","title":"SatelliteDataSources.encode","text":"encode(s::Type{AbstractSatellite}, raster::Rasters.AbstractRaster; encoding_type=UInt16, missingval=0x0000)\nencode(s::Type{AbstractSatellite}, raster::Rasters.AbstractRasterStack; kwargs...)\n\nEncode the provided raster(s) to Digital Numbers (DN).\n\nParameters\n\ns: The AbstractSatellite that produced the raster(s) in question.\nraster: Either a Rasters.Raster or Rasters.RasterStack to be encoded.\nencoding_type: The Julia type to use for storing the encoded values (default = UInt16).\nmissingval: The value to denote missing values (default = 0x0000).\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.Raster","page":"Home","title":"Rasters.Raster","text":"Raster(x::AbstractSatellite, layer::Symbol; kwargs...)\n\nRead a single layer into a Rasters.Raster.\n\nParameters\n\nx: An AbstractSatellite from which to read a layer.\nlayer: The layer to be read. See layers(s) for a list of available layers for sensor s.\nkwargs: Refer to the Rasters.Raster documentation for a summary of supported keywords.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterStack","page":"Home","title":"Rasters.RasterStack","text":"RasterStack(x::AbstractSatellite, layers=bands(T); kwargs...)\n\nRead multiple layers into a Rasters.RasterStack.\n\nParameters\n\nx: An AbstractSatellite from which to read a layer.\nlayer: The layer to be read. See layers(s) for a list of available layers for sensor s.\nkwargs: Refer to the Rasters.RasterStack documentation for a summary of supported keywords.\n\n\n\n\n\n","category":"type"},{"location":"#Visualization","page":"Home","title":"Visualization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Remotely sensed imagery is typically encoded as either UInt16 or Int16 values. However, many products only actually use the first 12 bits for storing information. The result is that naive visualization methods will produce a near-black image, since the maximum possible brightness will be located in the lower range of values provided by the 16 bit encoding. To address this, we need to perform a linear stretch before visualizing an image. Moreover, many satellites have more than three bands, which motivates the use of band combinations to emphasize certain features and land cover types.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"visualization.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.Agriculture","page":"Home","title":"RemoteSensingToolbox.Agriculture","text":"Used for crop monitoring and emphasizing healthy vegetation.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.ColorInfrared","page":"Home","title":"RemoteSensingToolbox.ColorInfrared","text":"Highlights vegetation in red, water in blue, and urban areas in grey.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Geology","page":"Home","title":"RemoteSensingToolbox.Geology","text":"Emphasizes geological formations, lithology features, and faults.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.SWIR","page":"Home","title":"RemoteSensingToolbox.SWIR","text":"Emphasizes dense vegetation in dark green and sparse vegetation in lighter shades.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.TrueColor","page":"Home","title":"RemoteSensingToolbox.TrueColor","text":"The true color band combination produces RGB images that are familiar to the human eye.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.visualize-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.visualize","text":"visualize(g::AbstractRaster; lower=0.02, upper=0.98)\nvisualize(r::AbstractRaster, g::AbstractRaster, b::AbstractRaster; lower=0.02, upper=0.98)\nvisualize(::Type{AbstractCombination{AbstractSatellite}}, img::AbstractRasterStack; kwargs...)\n\nVisualize a satellite image by applying a histogram stretch.\n\nReturns either an RGB or grayscale image compatible with the Images.jl ecosystem.\n\nExample\n\nusing RemoteSensingToolbox, ArchGDAL, Rasters, FileIO, JpegTurbo\n\n# Lazily Read Bands Into a RasterStack\nsrc = Landsat8(\"LC08_L2SP_043024_20200802_20200914_02_T1\")\nstack = RasterStack(src, lazy=true)\n\n# Display True Color Image\nimg = visualize(TrueColor{Landsat8}, stack; upper=0.90)\nFileIO.save(\"truecolor.jpg\", img)\n\n\n\n\n\n","category":"method"},{"location":"#Land-Cover-Indices","page":"Home","title":"Land Cover Indices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Land cover indices are used to highlight different types of land cover. For example, the Modified Normalized Difference Water  Index (MNDWI) is used to highlight water while diminishing built-up areas. Each index is expressed as a function of two or more  bands. RemoteSensingToolbox can automatically select the appropriate bands for a given index by providing an AbstractSatellite.  We also provide lower-level variants to enable the use of unsupported satellites.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"indices.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.mndwi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.mndwi","text":"mndwi(src::AbstractSatellite)\nmndwi(green::AbstractRaster, swir::AbstractRaster)\n\nCompute the Modified Normalised Difference Water Index (Xu 2006).\n\nMNDWI = (green - swir) / (green + swir)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.nbri-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.nbri","text":"nbri(src::AbstractSatellite)\nnbri(nir::AbstractRaster, swir2::AbstractRaster)\n\nCompute the Normalized Burn Ratio Index.\n\nNBRI is used to emphasize burned areas.\n\nNBRI = (nir - swir2) / (nir + swir2)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndbi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndbi","text":"ndbi(src::AbstractSatellite)\nndbi(swir1::AbstractRaster, nir::AbstractRaster)\n\nCompute the The Normalized Difference Built-up Index\n\nNDBI is used to emphasize urban and built-up areas.\n\nNDBI = (swir1 - nir) / (swir1 + nir)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndmi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndmi","text":"ndmi(src::AbstractSatellite)\nndmi(nir::AbstractRaster, swir1::AbstractRaster)\n\nCompute the Normalized Difference Moisture Index.\n\nNDMI is sensitive to the moisture levels in vegetation. It is used to monitor droughts and fuel levels in fire-prone areas.\n\nNDMI = (nir - swir1) / (nir + swir1)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndvi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndvi","text":"ndvi(src::AbstractSatellite)\nndvi(nir::AbstractRaster, red::AbstractRaster)\n\nCompute the Normalized Difference Vegetation Index.\n\nNDVI = (nir - red) / (nir + red)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndwi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndwi","text":"ndwi(src::AbstractSatellite)\nndwi(green::AbstractRaster, nir::AbstractRaster)\n\nCompute the Normalized Difference Water Index (McFeeters 1996).\n\nNDWI = (green - nir) / (green + nir)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.savi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.savi","text":"savi(src::AbstractSatellite; L=0.33)\nsavi(nir::AbstractRaster, red::AbstractRaster; L=0.33, scale=1.0, offset=0.0)\n\nCompute the Soil Adjusted Vegetation Index (Huete 1988).\n\nSAVI is a vegetation index which attempts to minimize soil brightness influences by introducing a soil-brightness correction factor (L).\n\nSAVI = ((nir - red) / (nir + red + L)) * (1 + L)\n\nKeywords\n\nL: The ammount of vegetative cover, where 1.0 means no vegetation and 0.0 means high vegetation.\nscale: The scaling factor to convert digital numbers to reflectance.\noffset: The offset to convert digital numbers to reflectance.\n\n\n\n\n\n","category":"method"},{"location":"#Spectral-Analysis","page":"Home","title":"Spectral Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spectral analysis involves studying the relationships between different materials and their corresponding spectral signatures. Due to the interactions between light and matter, each signature is unique to the material that emitted it. We can exploit this fact to assign a label to each pixel, or even estimate the abundances of different materials at a sub-pixel level.","category":"page"},{"location":"","page":"Home","title":"Home","text":"extract_signatures\nplot_signatures\nplot_signatures!","category":"page"},{"location":"#RemoteSensingToolbox.extract_signatures","page":"Home","title":"RemoteSensingToolbox.extract_signatures","text":"function extract_signatures([agg], raster, shp, label::Symbol)\n\nExtract signatures from a Raster or RasterStack within regions specified by a provided shapefile.\n\nParameters\n\nagg: A function to aggregate signatures belonging to the same class (ex. mean, median, maximum).\nraster: An AbstractRaster or AbstractRasterStack from which to extract the spectral signatures.\nshp: A table with a :geometry column of GeoInterface.jl geometries and land cover labels.\nlabel: The column in shp corresponding to the land cover type.\n\nReturns\n\nA Tables.columntable containing all labelled signatures or their aggregation if agg is provided.\n\nExample\n\njulia> src = Landsat8(\"LC08_L2SP_043024_20200802_20200914_02_T1/\");\n\njulia> sr = decode(Landsat8, RasterStack(src, [:B1, :B2, :B3, :B4, :B5]));\n\njulia> shp = GeoDataFrames.read(\"data/landcover/landcover.shp\");\n\njulia> extract_signatures(sr, shp, :C_name) |> DataFrame\n1925×6 DataFrame\n  Row │ label      B1         B2         B3        B4        B5       \n      │ String     Float32    Float32    Float32   Float32   Float32  \n──────┼───────────────────────────────────────────────────────────────\n    1 │ Hail Scar  0.058005   0.10613    0.19028   0.25177   0.51577\n    2 │ Hail Scar  0.057895   0.10888    0.19358   0.257215  0.520198\n    3 │ Hail Scar  0.06026    0.111795   0.197265  0.263045  0.523855\n    4 │ Hail Scar  0.0595175  0.109375   0.195257  0.258315  0.522287\n    5 │ Hail Scar  0.059215   0.108468   0.191655  0.254327  0.51401\n  ⋮   │     ⋮          ⋮          ⋮         ⋮         ⋮         ⋮\n 1921 │ Built Up   0.0633125  0.0914725  0.145565  0.165227  0.255153\n 1922 │ Built Up   0.0764025  0.100878   0.154392  0.176063  0.24363\n 1923 │ Built Up   0.09788    0.126342   0.180738  0.19941   0.25958\n 1924 │ Built Up   0.0973025  0.133163   0.1894    0.198475  0.278775\n 1925 │ Built Up   0.06345    0.089685   0.145042  0.158243  0.272505\n                                                     1915 rows omitted\n\njulia> extract_signatures(mean, sr, shp, :C_name) |> DataFrame\n7×6 DataFrame\n Row │ label       B1          B2          B3         B4          B5       \n     │ String      Float32     Float32     Float32    Float32     Float32  \n─────┼─────────────────────────────────────────────────────────────────────\n   1 │ Hail Scar   0.0618124   0.107894    0.187857   0.24683     0.507976\n   2 │ Bare Earth  0.0484324   0.053983    0.0775185  0.0886341   0.231951\n   3 │ Road        0.0400183   0.0534427   0.0938634  0.0958244   0.245025\n   4 │ Lake        0.00137886  0.00423271  0.0135606  0.00652965  0.031825\n   5 │ Trees       0.0183338   0.0203976   0.0401544  0.024148    0.318622\n   6 │ Vegetation  0.00441971  0.0157759   0.0787841  0.0463343   0.495117\n   7 │ Built Up    0.0845031   0.113944    0.174032   0.197151    0.283717\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.plot_signatures","page":"Home","title":"RemoteSensingToolbox.plot_signatures","text":"plot_signatures(bandset::Type{<:AbstractSatellite}, sigs; kwargs...)\nplot_signatures(bandset::Vector{<:Pair}, sigs; colors=Makie.wong_colors(), label=:label)\n\nPlot the spectral signatures for one or more land cover types.\n\nParameters\n\nbandset: An AbstractSatellite or a vector of sorted band => wavelength pairs.\nsigs: A table whose rows consist of spectral signatures and their associated labels.\n\nKeywords\n\nlabel: The column in sigs containing the signature labels (default = :label).\ncolors: The color scheme used by the plot (default = Makie.wong_colors()).\n\nExample\n\njulia> src = Landsat8(\"LC08_L2SP_043024_20200802_20200914_02_T1\");\n\njulia> surface_reflectance = decode(Landsat8, RasterStack(src));\n\njulia> shp = GeoDataFrames.read(\"data/landcover/landcover.shp\");\n\njulia> sigs = extract_signatures(mean, surface_reflectance, shp, :MC_name);\n\njulia> plot_signatures(Landsat8, sigs, colors=[:brown, :orange, :blue, :green])\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.plot_signatures!","page":"Home","title":"RemoteSensingToolbox.plot_signatures!","text":"plot_signatures!(ax, bandset::Type{<:AbstractSatellite}, sigs; kwargs...)\nplot_signatures!(ax, bandset::Vector{<:Pair}, sigs; colors=Makie.wong_colors(), label=:label)\n\nPlot the spectral signatures for one or more land cover types onto an existing Makie.Axis.\n\nParameters\n\nax: The Makie.Axis onto which to plot the signatures.\nbandset: An AbstractSatellite or a vector of sorted band => wavelength pairs.\nsigs: A table whose rows consist of spectral signatures and their associated labels.\n\nKeywords\n\nlabel: The column in sigs containing the signature labels (default = :label).\ncolors: The color scheme used by the plot (default = Makie.wong_colors()).\n\nExample\n\nusing RemoteSensingToolbox, Rasters, GeoDataFrames, Statistics, CairoMakie\n\n# Read Images And Convert DNs To Reflectance\nlandsat = Landsat8(\"data/LC08_L2SP_043024_20200802_20200914_02_T1/\")\nsentinel = Sentinel2{20}(\"data/T11UPT_20200804T183919/\")\nlandsat_reflectance = decode(Landsat8, RasterStack(landsat))\nsentinel_reflectance = decode(Sentinel2, RasterStack(sentinel))\n\n# Read Landcover Labels From Shapefile\nshp = GeoDataFrames.read(\"data/landcover/landcover.shp\")\n\n# Extract Average Spectral Signature For Each Landcover Type\nlandsat_sigs = extract_signatures(mean, landsat_reflectance, shp, :MC_name)\nsentinel_sigs = extract_signatures(mean, sentinel_reflectance, shp, :MC_name)\n\n# Create Figure and Axis\nfig = Figure(resolution=(800,550));\nax1 = Axis(fig[1,1], ylabel=\"Reflectance\", title=\"Landsat Signatures\")\nax2 = Axis(fig[2,1], xlabel=\"Wavelength (nm)\", ylabel=\"Reflectance\", title=\"Sentinel Signatures\")\n\n# Plot Signatures\nplot_signatures!(ax1, Landsat8, landsat_sigs, colors=[:brown, :orange, :blue, :green])\nplot_signatures!(ax2, Sentinel2{20}, sentinel_sigs, colors=[:brown, :orange, :blue, :green])\n\n# Add Legend\nLegend(fig[:,2], ax1)\n\n\n\n\n\n","category":"function"},{"location":"#Principal-Component-Analysis","page":"Home","title":"Principal Component Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Principal Component Analysis (PCA) is typically used to reduce the dimensionality of data. In the case of remote sensing, we are interested in reducing the number of bands we need to store while retaining as much information as possible. PCA rotates the bands into a new coordinate space where each band, called a principal component, is orthogonal to and uncorrelated with every other component. By convention, we order the bands in the transformed image in terms of their explained variance, such that the nth component accounts for more variance than any component after it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"pca.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.PCA","page":"Home","title":"RemoteSensingToolbox.PCA","text":"Remotely sensed imagery typically consists of anywhere from four to several hundred spectral bands. These bands are often highly correlated due to occupying similar spectral regions. Principal Component Analysis (PCA) is used in remote sensing to:\n\nCreate a smaller dataset from multiple bands, while retaining as much of the original spectral information as possible. The new image will consist of several uncorrelated PC bands.\nReveal complex relationships among spectral features.\nDistinguish between characteristics that are prevalent in most bands and those that are specific to only a few.\n\nExample\n\njulia> desis = DESIS(\"DESIS-HSI-L2A-DT0884573241_001-20200601T234520-V0210/\");\n\njulia> desis_bands = Raster(desis, :Bands)\n\njulia> pca = fit_pca(desis_bands, stats_fraction=0.1)\nPCA(dimensions=235) \n\nProjection Matrix:\n235×235 Matrix{Float32}:\n  0.0001  0.0032   0.0016  -0.0094   0.0147  -0.0151  -0.0049   0.0163  …   0.0038  -0.0012   0.0008  -0.0032  -0.0007   0.0053\n  0.0005  0.0099   0.0042  -0.0244   0.0517  -0.0335  -0.0185   0.0441     -0.0023  -0.0016  -0.0008   0.001    0.0003  -0.0004\n  0.0003  0.015    0.0053  -0.037    0.133   -0.0443  -0.0271   0.1381     -0.0006   0.0004   0.0002  -0.0006   0.0003   0.0002\n  0.0003  0.019    0.0071  -0.0385   0.1369  -0.0393  -0.0148   0.0949     -0.0008   0.0006  -0.0001  -0.0006   0.0001  -0.0006\n  0.0003  0.0232   0.0073  -0.0419   0.1469  -0.037    0.0041   0.0839     -0.0013  -0.0025   0.0005   0.0007   0.0007  -0.0002\n  0.0001  0.0267   0.0077  -0.0461   0.1713  -0.0325   0.0246   0.0861  …   0.0013  -0.0007  -0.0007   0.0024  -0.0012  -0.0028\n  0.0001  0.0295   0.0083  -0.0476   0.1695  -0.0348   0.0319   0.0827     -0.0015  -0.0016  -0.0029   0.0004   0.0019  -0.0009\n -0.0001  0.0318   0.0086  -0.0482   0.17    -0.0352   0.0414   0.0784      0.0005  -0.002    0.0003   0.0021  -0.0003  -0.0022\n  ⋮                                           ⋮                         ⋱            ⋮                                  \n -0.0663  0.0371  -0.1728   0.0196  -0.0508  -0.1394  -0.0054  -0.0226     -0.0003   0.0001   0.0007  -0.0009  -0.0002   0.0004\n -0.0658  0.0365  -0.1679   0.0204  -0.0717  -0.1474  -0.0087  -0.0193     -0.0006   0.0002   0.0004  -0.0      0.0004  -0.0001\n -0.0655  0.0352  -0.163    0.0193  -0.0767  -0.1511  -0.012   -0.0232     -0.0005   0.0002  -0.0004  -0.0001  -0.0002   0.0005\n -0.066   0.035   -0.1618   0.0193  -0.0859  -0.1503  -0.0055  -0.0177  …   0.0003   0.0005   0.001   -0.0      0.0003  -0.0002\n -0.067   0.035   -0.1619   0.019   -0.0745  -0.1466   0.0245  -0.0228     -0.0001   0.0002  -0.0002  -0.0001  -0.0002   0.0005\n -0.0679  0.0343  -0.1601   0.0176  -0.0721  -0.139    0.0328  -0.0286      0.0003   0.0003   0.0005  -0.0      0.0003   0.0002\n -0.0682  0.0337  -0.1588   0.0151  -0.0458  -0.1242   0.0549  -0.0315      0.0002  -0.0002  -0.0003   0.0002  -0.0003  -0.0005\n -0.0711  0.0343  -0.1601   0.012   -0.0612  -0.1804   0.2151  -0.0971      0.0004  -0.0001   0.0      0.0003   0.0     -0.0003\n\nImportance of Components:\n  Cumulative Variance: 0.8782  0.9493  0.9809  0.9869  0.9889  0.9906  0.9915  0.9922  0.9928  ...  1.0\n  Explained Variance: 0.8782  0.0711  0.0316  0.006  0.0021  0.0017  0.0009  0.0007  0.0006  ...  0.0\n\njulia> transformed = forward_pca(pca, desis_bands, 12);\n\njulia> size(transformed)\n(1131, 1120, 12)\n\njulia> recovered = inverse_pca(pca, transformed);\n\njulia> size(recovered)\n(1131, 1120, 235)\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.cumulative_variance-Tuple{PCA}","page":"Home","title":"RemoteSensingToolbox.cumulative_variance","text":"cumulative_variance(x::PCA)\n\nReturn the cumulative variance associated with each principal component of the fitted PCA transform.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.explained_variance-Tuple{PCA}","page":"Home","title":"RemoteSensingToolbox.explained_variance","text":"explained_variance(x::PCA)\n\nReturn the explained variance associated with each principal component of the fitted PCA transform.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.fit_pca-Tuple{Union{Rasters.AbstractRaster, Rasters.AbstractRasterStack}}","page":"Home","title":"RemoteSensingToolbox.fit_pca","text":"fit_pca(raster::Union{<:AbstractRasterStack, <:AbstractRaster}; method=:cov, stats_fraction=1.0)\nfit_pca(signatures::Matrix{Float32}; method=:cov, stats_fraction=1.0)\n\nFit a Principal Component Analysis (PCA) transformation to the given raster or spectral signatures.\n\nParameters\n\nraster: The AbstractRaster or AbstractRasterStack on which to fit the PCA transformation.\nsignatures: An nxb matrix of spectral signatures where n is the number of signatures and b is the number of bands.\n\nKeywords\n\nmethod: Either :cov or :cor, depending on whether we want to use the covariance or correlation matrix for computing the PCA rotation.\nstats_fraction: The fraction of pixels to use when computing the covariance (or correlation) matrix. Values less than 1.0 will speed up computation at the cost of precision.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.forward_pca-Tuple{PCA, Rasters.AbstractRasterStack, Int64}","page":"Home","title":"RemoteSensingToolbox.forward_pca","text":"forward_pca(transformation::PCA, raster::Union{<:AbstractRaster, <:AbstractRasterStack}, components::Int)\nforward_pca(transformation::PCA, signatures::Matrix, components::Int)\n\nPerform a forward Principal Component Analysis (PCA) rotation while retaining only the specified number of components.\n\nParameters\n\ntransformation: A previously fitted PCA transformation.\nraster: The AbstractRaster or AbstractRasterStack on which to perform the PCA transformation.\nsignatures: An nxb matrix of signatures where n is the number of signatures and b is the number of bands.\ncomponents: The number of bands to retain in the transformed image or signatures.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.inverse_pca-Tuple{PCA, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.inverse_pca","text":"inverse_pca(transformation::PCA, raster::AbstractRaster)\ninverse_pca(transformation::PCA, signatures::Matrix)\n\nPerform an inverse Principal Component Analysis (PCA) transformation to recover the original image.\n\nParameters\n\ntransformation: A previously fitted PCA transformation.\nraster: An AbstractRaster representing a previously transformed image.\nsignatures: An nxc matrix of previously transformed signatures where n is the number of signatures and c is the number of components.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.projection-Tuple{PCA}","page":"Home","title":"RemoteSensingToolbox.projection","text":"projection(x::PCA)\n\nReturn the projection matrix for the fitted PCA transformation.\n\n\n\n\n\n","category":"method"},{"location":"#Minimum-Noise-Fraction","page":"Home","title":"Minimum Noise Fraction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Minimum Noise Fraction (MNF) transformation is used to separate noise from data along the spectral dimension. This method is typically used with hyperspectral imagery, both as a means of dimension reduction and for noise removal. The transformed image will have its bands placed in descending order according to their Signal to Noise Ratio (SNR). The result is that the noise becomes concentrated in the higher bands, which can then be removed by either applying a standard image denoising algorithm or dropping them altogether.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"mnf.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.MNF","page":"Home","title":"RemoteSensingToolbox.MNF","text":"The Minimum Noise Fraction (MNF) transform is a linear transformation used to reduce the spectral dimensionality of image data and  segregate noise. MNF consists of two separate principal component rotations. The first rotation uses the principal components  of the noise covariance matrix to decorrelate and rescale the noise (a process known as noise whitening), resulting in a transformed  image in which the noise has unit variance and no band-to-band correlations. The second rotation is a standard PCA rotation  applied to the noise-whitened image.\n\nThe bands in the transformed image will be ordered according to their Signal to Noise Ratio (SNR), with the highest SNR being  placed first. The result is that the noise becomes concentrated in the higher bands. Thus, the transform can be used to separate  noise from data by performing a forward transform, determining which bands contain coherent images, and running an inverse  transform after either discarding or denoising the remaining bands. The number of bands to keep in the inverse transform can be determined by a number  of methods. The simplest approach is to look at the sorted transformed bands and threshold at the band where no recognizable  features can be observed. An alternative method is to threshold at a desired cumulative SNR.\n\nExample\n\njulia> desis = read_bands(DESIS, \"data/DESIS-HSI-L2A-DT0884573241_001-20200601T234520-V0210/\");\n\njulia> roi = @view desis[X(1019:1040), Y(550:590)];\n\njulia> mnf = fit_mnf(desis, roi)\nMNF(dimensions=235) \n\nProjection Matrix:\n235×235 Matrix{Float32}:\n -2.135    2.3502   0.3612   0.5912   0.5217  -0.0917   0.0043  …   0.0002  -0.0001  -0.0004  -0.0004  -0.0      0.0004\n -0.0959   0.0422  -0.0047  -0.2362  -0.3962  -0.2313  -0.1685      0.0001   0.0004   0.0002   0.0003   0.0001  -0.0001\n  0.0043   0.0058  -0.0032   0.0023  -0.0061  -0.0048   0.0028     -0.0001   0.0001  -0.0001  -0.0      0.0      0.0001\n  0.0039   0.002   -0.002    0.0012  -0.0032  -0.004    0.006      -0.0006   0.0002  -0.0001  -0.0     -0.0003  -0.0\n  0.0024   0.0018  -0.003   -0.0008   0.0038  -0.0003   0.0057      0.0009  -0.0007   0.0002  -0.0012   0.0012  -0.0\n  0.0019  -0.003    0.0038  -0.002   -0.0001  -0.0003  -0.0     …   0.0021   0.0009  -0.0004   0.0014  -0.0011  -0.0006\n  0.0047   0.0055   0.006   -0.0014  -0.0011   0.0021   0.0053     -0.0035   0.0006   0.0002  -0.0026   0.0014   0.0019\n  0.0072   0.0042   0.0012   0.0016   0.0011  -0.002   -0.001       0.0     -0.0026   0.0012   0.0034  -0.0006  -0.0009\n  ⋮                                            ⋮                ⋱            ⋮                                  \n -0.0004  -0.0012   0.0007   0.0006  -0.0      0.0002   0.0005      0.0005   0.0002  -0.0004  -0.0002  -0.0001   0.0001\n -0.0014  -0.0005  -0.0005   0.0019  -0.0002  -0.0005   0.0017      0.0003   0.0005   0.0      0.0004   0.0005   0.0\n -0.0004   0.0008  -0.0003   0.0013   0.0004   0.0014   0.0004      0.0002  -0.0001   0.0002   0.0001  -0.0002  -0.0002\n -0.0008  -0.0015   0.0021  -0.0004  -0.0004   0.0012   0.0006  …  -0.0011   0.0002  -0.0007   0.0001   0.0005  -0.0001\n  0.0008  -0.0004   0.0009   0.0019  -0.0022  -0.0014   0.0013      0.0003  -0.0001  -0.0003  -0.0      0.0003   0.0002\n  0.0005   0.0006  -0.0022  -0.0003   0.0     -0.0022   0.0016     -0.001    0.0002  -0.0003   0.0003  -0.0005   0.0005\n  0.001   -0.0005  -0.0007   0.0025  -0.0019   0.0005   0.0015      0.0002  -0.0005   0.0     -0.0005   0.0002  -0.0002\n -0.0003   0.0002  -0.0021  -0.0008  -0.0012   0.0003   0.0003     -0.0001  -0.0      0.0001   0.0      0.0      0.0\n\nComponent Statistics:\n  Eigenvalues: 7975.439  4040.6348  2092.866  717.8178  468.5496  247.5029  202.2003  176.8452  87.3302  ...  0.3602\n  Cumulative Eigenvalues: 0.4779  0.72  0.8454  0.8884  0.9165  0.9313  0.9434  0.954  0.9593  ...  1.0\n  Explained SNR: 7974.4385  4039.6353  2091.8635  716.8176  467.55  246.5022  201.1985  175.845  86.3301  ...  -0.6399\n  Cumulative SNR: 0.4839  0.729  0.856  0.8995  0.9278  0.9428  0.955  0.9657  0.9709  ...  0.9985\n\njulia> transformed = forward_mnf(mnf, desis, 12);\n\njulia> size(transformed)\n(1131, 1120, 12)\n\njulia> recovered = inverse_mnf(mnf, transformed);\n\njulia> size(recovered)\n(1131, 1120, 235)\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.cumulative_eigenvalues-Tuple{MNF}","page":"Home","title":"RemoteSensingToolbox.cumulative_eigenvalues","text":"cumulative_eigenvalues(x::MNF)\n\nReturn the cumulative eigenvalues associated with each principal components of the fitted MNF transform.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.cumulative_snr-Tuple{MNF}","page":"Home","title":"RemoteSensingToolbox.cumulative_snr","text":"cumulative_snr(x::MNF)\n\nReturn the cumulative SNR associated with each principal components of the fitted MNF transform.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.data_cov-Tuple{MNF}","page":"Home","title":"RemoteSensingToolbox.data_cov","text":"data_cov(x::MNF)\n\nReturn the data covariance matrix for the fitted MNF transform.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.eigenvalues-Tuple{MNF}","page":"Home","title":"RemoteSensingToolbox.eigenvalues","text":"eigenvalues(x::MNF)\n\nReturn the eigenvalues associated with each principal components of the fitted MNF transform.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.estimate_noise-Tuple{Union{Rasters.AbstractRaster, Rasters.AbstractRasterStack}}","page":"Home","title":"RemoteSensingToolbox.estimate_noise","text":"estimate_noise(raster::Union{<:AbstractRaster, <:AbstractRasterStack}; smooth=false)\n\nEstimate the noise covariance matrix for the given raster.\n\nUses the Minimum/Maximum Autocorrelation Factor proposed by Switzer and Green.\n\nFor best results, the provided raster should be spectrally homoegenous (e.g., an open field or body of water).\n\nParameters\n\nraster: An AbstractRaster or AbstractRasterStack.\nsmooth: Numerical stability requires that no bands have a variance of zero. A smoothing term can be applied to ensure that this is the case.\n\nExample\n\nusing RemoteSensingToolbox, Rasters\n\n# Load Data\nsrc = DESIS(\"DESIS-HSI-L2A-DT0485529167_001-20220712T223540-V0220\")\ndesis = decode(DESIS, Raster(src, :Bands))\n\n# Extract Homogenous Region of Interest\nroi = desis[X(1019:1040), Y(550:590)]\n\n# Estimate Noise\nncm = estimate_noise(roi, smooth=true)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.fit_mnf-Tuple{Union{Rasters.AbstractRaster, Rasters.AbstractRasterStack}, Matrix}","page":"Home","title":"RemoteSensingToolbox.fit_mnf","text":"fit_mnf(raster, noise_sample; smooth=true)\n\nFit a Minimum Noise Fraction (MNF) transformation to the given AbstractRasterStack or AbstractRaster.\n\nParameters\n\nraster: The AbstractRaster or AbstractRasterStack on which to fit the MNF transformation.\nnoise_sample: A homogenous (spectrally uniform) region extracted from raster for calculating the noise covariance matrix.\nsmooth: The MNF transform cannot be computed if any band in noise_sample has zero variance. To correct this, you may wish to introduce a small smoothing term (true by default).\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.forward_mnf-Tuple{MNF, Rasters.AbstractRasterStack, Int64}","page":"Home","title":"RemoteSensingToolbox.forward_mnf","text":"forward_mnf(transformation::MNF, raster, components::Int)\nforward_mnf(transformation::MNF, sigs::Matrix, components::Int)\n\nPerform a forward Minimum Noise Fraction (MNF) rotation on the given raster or signatures, retaining only the specified number of components.\n\nParameters\n\ntransformation: A previously fitted MNF transformation.\nraster: The AbstractRaster or AbstractRasterStack on which to perform the MNF transformation.\nsigs: An n x b matrix of spectral signatures where n is the number of signatures and b is the number of bands.\ncomponents: The number of bands to retain in the transformed image. All band numbers exceeding this value will be discarded.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.inverse_mnf-Tuple{MNF, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.inverse_mnf","text":"inverse_mnf(transformation::MNF, raster::AbstractRaster)\ninverse_mnf(transformation::MNF, sigs::Matrix)\n\nPerform an inverse Minimum Noise Fraction (MNF) transformation to recover the original image or signatures.\n\nParameters\n\ntransformation: A previously fitted MNF transformation.\nraster: An AbstractRaster representing a previously transformed image. The number of bands should be less than or equal to that of the original image.\nsigs: An n x p matrix of transformed signatures where n is the number of signatures and p is the number of retained components.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.noise_cov-Tuple{MNF}","page":"Home","title":"RemoteSensingToolbox.noise_cov","text":"noise_cov(x::MNF)\n\nReturn the noise covariance matrix for the fitted MNF transform.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.projection-Tuple{MNF}","page":"Home","title":"RemoteSensingToolbox.projection","text":"projection(x::MNF)\n\nReturn the projection matrix for the fitted MNF transform.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.snr-Tuple{MNF}","page":"Home","title":"RemoteSensingToolbox.snr","text":"snr(x::MNF)\n\nReturn the estimated SNR associated with each principal components of the fitted MNF transform.\n\n\n\n\n\n","category":"method"},{"location":"#Utilities","page":"Home","title":"Utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RemoteSensingToolbox provides several utility functions for modifying and processing remotely sensed data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"utils.jl\"]\nPrivate = false","category":"page"}]
}

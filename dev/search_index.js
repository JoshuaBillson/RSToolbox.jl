var documenterSearchIndex = {"docs":
[{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"RemoteSensingToolbox provides a number of utilities for visualizing, manipulating, and interpreting remotely sensed imagery. First, lets load the imagery we want to work with. We're using Landsat 8 imagery in this example, so we'll pass the Landsat8 type to read_bands so it knows how to parse the relevant files from the provided directory. Landsat8 is an instance of AbstractBandset, which is the supertype responsible for allowing many methods within RemoteSensingToolbox to infer sensor-specific information by exploiting Julia's multiple dispatch system.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using RemoteSensingToolbox, Rasters\nusing Pipe: @pipe\n\nlandsat = read_bands(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now let's visualize our data to see what we're working with. This is where the power of AbstractBandset can first be demonstrated. To view a true color composite of the data, we need to know the bands corresponding to red, green, and blue. However, it would be tedious to memorize and manually specify this information whenever we want to call a method which relies on a specific combination of bands. Fortunately, all AbstractBandset types know this information implicitly, so all we need to do is pass in Landsat8 as a parameter to TrueColor.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"visualize(landsat, TrueColor{Landsat8}; upper=0.90)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"You may have noticed that we provided an additional argument upper to the visualize method. This parameter controls the upper quantile to be used when performing histogram stretching to make the imagery interpretable to humans. This parameter is set to 0.98 by default, but because our scene contains a significant number of bright clouds, we need to lower it to prevent the image from appearing too dark. We can remove these clouds by first loading the Quality Assurance (QA) mask that came with our landsat product and then calling mask_pixels.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"qa = read_qa(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")\n\nmasked_landsat = @pipe mask_pixels(landsat, qa[:cloud]) |> mask_pixels(_, qa[:cloud_shadow])\n\nvisualize(masked_landsat, TrueColor{Landsat8})","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now let's try to visualize some other band combinations. The Agriculture band comination is commonly used to distinguish regions with healthy vegetation, which appear as various shades of green.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"visualize(landsat, Agriculture{Landsat8}; upper=0.90)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"We can also convert Digital Numbers (DNs) to reflectance by calling dn_to_reflectance and passing in the appropriate bandset.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"landsat_sr = dn_to_reflectance(Landsat8, landsat)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"We'll finish this example by demonstrating how to compute land cover indices with any AbstractBandset type. The Modified Normalized Difference Water Index (MNDWI) is used to help distinguish water from land. Here, we visualize both the true color representation and the corresponding MNDWI index.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"roi = @view landsat_sr[X(5800:6800), Y(2200:3200)]\n\ntrue_color = visualize(roi, TrueColor{Landsat8}; upper=0.998)\n\nindex = mndwi(roi, Landsat8) |> visualize\n\nmosaicview(true_color, index; npad=5, fillvalue=0.0, ncol=2)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"spectral_example/#Spectral-Analysis","page":"Spectral Analysis","title":"Spectral Analysis","text":"","category":"section"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"A common application of remotely sensed imagery is land cover classification. One method to accomplish this is to analyze the spectral signatures produced by different types of cover. RemoteSensingToolbox provides a number of functions for extracting and visualyzing spectral signatures organized by their associated lan cover.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"The first step in our analysis is to load our remotely sensed data and convert the DNs (Digital Numbers) to reflectances. Reflectance is a standardized unit of measurement defined over the interval [0, 1] which denotes the fraction of light that is reflected by the observed surface. A reflectance of 0.0 indicates that no light was reflected whereas a reflectance of 1.0 indicates that 100% of light was reflected.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"using RemoteSensingToolbox, DataFrames, Shapefile, CairoMakie\nusing Pipe: @pipe\n\nlandsat = @pipe read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"Next, we need to load a shapefile which defines some regions containing each type of land cover that we're interested in.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"shp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"Examining the shapefile gives us some idea of how its contents are structured. As we can see, the regions of interest are stored as Polygon objects under the :geometry column, while the land cover types are under :MC_name and :C_name. The :MC_name column defines the macroclass, which in our case are built up land, vegetation, bare earth, and water. The :C_name column defines the specific class to which some land cover belongs. For example, both \"Trees\" and \"Vegetation\" belong to the \"Vegetation\" macroclass.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"8×7 DataFrame\n Row │ geometry            fid      MC_ID  MC_name     C_ID   C_name      SCP_UID                   \n     │ Polygon             Missing  Int64  String      Int64  String      String                    \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Polygon(38 Points)  missing      1  Built Up        1  Built Up    20230527_122212594060_314\n   2 │ Polygon(31 Points)  missing      1  Built Up        2  Road        20230527_122301732906_304\n   3 │ Polygon(7 Points)   missing      2  Vegetation      3  Vegetation  20230527_122832068862_302\n   4 │ Polygon(57 Points)  missing      2  Vegetation      4  Trees       20230527_123221462871_572\n   5 │ Polygon(5 Points)   missing      3  Bare Earth      5  Hail Scar   20230527_123631491671_937\n   6 │ Polygon(7 Points)   missing      3  Bare Earth      6  Bare Earth  20230527_123727873290_779\n   7 │ Polygon(7 Points)   missing      4  Water           7  Lake        20230527_123931189139_867\n   8 │ Polygon(5 Points)   missing      3  Bare Earth      6  Bare Earth  20230527_125120033074_286","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"We can extract the signatures inside each polygon with extract_signatures. This method returns a RasterTable, which is a special type optimized for extracting tablular data from a raster data source. Because RasterTable implements the Tables.jl interface, it can be directly sunk into other table constructors, such as  DataFrames, and is also compatible with external libraries like TableOperations.jl.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"sigs = extract_signatures(landsat, shp, :C_name) |> DataFrame","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"1925×8 DataFrame\n  Row │ B1         B2         B3        B4        B5        B6        B7        label     \n      │ Float32    Float32    Float32   Float32   Float32   Float32   Float32   String    \n──────┼───────────────────────────────────────────────────────────────────────────────────\n    1 │ 0.057235   0.10547    0.188932  0.24847   0.513405  0.315323  0.166107  Hail Scar\n    2 │ 0.0574     0.105415   0.188712  0.24946   0.513735  0.317908  0.167593  Hail Scar\n    3 │ 0.0584175  0.107175   0.19182   0.253887  0.515577  0.319585  0.168087  Hail Scar\n    4 │ 0.0583625  0.10723    0.190995  0.253393  0.514615  0.317715  0.167097  Hail Scar\n    5 │ 0.05806    0.10745    0.189895  0.250368  0.50774   0.315048  0.165475  Hail Scar\n    6 │ 0.05553    0.102885   0.184175  0.243272  0.498417  0.307485  0.160938  Hail Scar\n    7 │ 0.05267    0.0983475  0.176585  0.230073  0.48783   0.29159   0.153292  Hail Scar\n  ⋮   │     ⋮          ⋮         ⋮         ⋮         ⋮         ⋮         ⋮          ⋮\n 1919 │ 0.0320725  0.05993    0.11306   0.127415  0.272258  0.27322   0.220777  Built Up\n 1920 │ 0.100575   0.127168   0.199218  0.23164   0.285677  0.323985  0.258645  Built Up\n 1921 │ 0.077145   0.112097   0.17081   0.19677   0.25705   0.320877  0.28015   Built Up\n 1922 │ 0.10712    0.136765   0.19666   0.225068  0.268655  0.33284   0.302288  Built Up\n 1923 │ 0.0856425  0.123235   0.185853  0.211675  0.273     0.373623  0.351072  Built Up\n 1924 │ 0.088145   0.119578   0.17059   0.204442  0.27487   0.355857  0.325553  Built Up\n 1925 │ 0.0518725  0.0816275  0.148673  0.15189   0.28774   0.309218  0.29786   Built Up\n                                                                         1911 rows omitted","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"While extract_signatures can be a good first step for further statistical analysis or training classification modelsFinally, we are also often interested in visualizing the spectral signatures associated with each land cover type. To to do, we can call plot_signatures, which plots each signature as a CairoMakie line graph.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"plot_signatures(Landsat8, landsat, shp, :C_name)","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"(Image: )","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"We see that we've plotted the signatures for each land cover type in shp. However, we may wish to override the default colors. Fortunately, plot_signatures accepts an optional argument allowing us to specify any colors that we wish.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"plot_signatures(Landsat8, landsat, shp, :C_name; colors=cgrad(:tab10))","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"(Image: )","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"The plot_signatures! method is nearly identical to plot_signatures, but it expects a Makie.Axis object as its first argument onto which the signatures will be drawn (hence the exclamation). This allows us to create more sophisticated plots than are supported by plot_signatures. We will demonstrate this capability by plotting the same signatures for three different sensors, each of which passed over our study area within a period of four days. ","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"# Load Sentinel and DESIS\nsentinel = @pipe read_bands(Sentinel2, \"data/T11UPT_20200804T183919/R60m/\") |> dn_to_reflectance(Sentinel2, _)\ndesis = @pipe read_bands(DESIS, \"data/DESIS-HSI-L2A-DT0884573241_001-20200601T234520-V0210\") |> dn_to_reflectance(DESIS, _)\nsensors = [landsat, sentinel, desis]\n\n# Create Figure\nfig = Figure(resolution=(1000, 800))\n\n# Create Axes\nax1 = Axis(fig[1,1], title=\"Landsat 8\", xticksvisible=false, xticklabelsvisible=false)\nax2 = Axis(fig[2,1], title=\"Sentinel 2\", ylabel=\"Reflectance\", ylabelfont=:bold, xticksvisible=false, xticklabelsvisible=false)\nax3 = Axis(fig[3,1], title=\"DESIS\", xlabel=\"Wavelength (nm)\", xlabelfont=:bold)\naxs = [ax1, ax2, ax3]\n\n# Plot Signatures\ncolors = cgrad([:saddlebrown, :navy, :orange, :green], 4, categorical=true)\nfor (bandset, sensor, ax) in zip((Landsat8, Sentinel2, DESIS), sensors, axs)\n   plot_signatures!(ax, bandset, sensor, shp, :MC_name; colors=colors)\n   xlims!(ax, 400, 1000)\nend\n\n# Add Legend\nLegend(fig[1:3,2], first(axs), \"Classification\")","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"pca_example/#Principal-Component-Analysis","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"","category":"section"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Remotely sensed imagery typically consists of anywhere from five to several hundred spectral bands. These bands are often highly correlated because they occupy similar spectral regions. ","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"PCA is used in remote sensing to:","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Create a smaller dataset from multiple bands, while retaining as much of the original spectral information as possible. The new image will consist of several uncorrelated PC bands.\nReveal complex relationships among spectral features.\nDetermine which characteristics are prevalent in most of the bands, and those that are specific to only a few.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Our first step is to load and visualize our initial image.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"using RemoteSensingToolbox, Rasters\nusing Pipe: @pipe\n\nsentinel = read_bands(Sentinel2, \"data/T11UPT_20200804T183919/R60m/\")\nroi = @view sentinel[Rasters.X(900:1799), Rasters.Y(1:900)]\nvisualize(roi, TrueColor{Sentinel2}; upper=0.99)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Next, we'll fit a PCA transformation to our image. The reason that we make fitting and transformation seperate is so that the procedure can be repeated and reversed. We'll try keeping all of the components at first so we can get a sense of how many we'll need to retain. ","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"pca = fit_pca(sentinel, method=:cov)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"PCA(dimensions=11) \n\nProjection Matrix:\n11×11 Matrix{Float32}:\n -0.026   -0.2068  -0.359    0.312   -0.0955  -0.4791   0.2245  -0.6117   0.1862  -0.1494   0.1005\n -0.0361  -0.2354  -0.3739   0.1417  -0.0495  -0.1544   0.3841   0.3908  -0.3467   0.2438  -0.5265\n -0.0775  -0.2406  -0.3554  -0.1492   0.0607   0.0575   0.0611   0.2326  -0.4335  -0.2812   0.6751\n -0.0396  -0.3231  -0.321   -0.0301  -0.048    0.4006   0.1103   0.1691   0.6681   0.3318   0.1738\n -0.1194  -0.2914  -0.2233  -0.3824   0.3987   0.3538  -0.1552  -0.388   -0.0944  -0.2647  -0.4087\n -0.3925   0.0354  -0.0791  -0.5717   0.1024  -0.5641  -0.2124   0.0649   0.1101   0.3449   0.0496\n -0.4949   0.1513  -0.0179  -0.1062  -0.4124   0.0178   0.1554   0.231    0.257   -0.6108  -0.1833\n -0.5257   0.084   -0.0977   0.6026   0.4321   0.0232  -0.3684   0.1418   0.0193   0.0173   0.0145\n -0.155   -0.549    0.63     0.0248   0.3084  -0.1466   0.361    0.095    0.0889  -0.0983   0.0592\n -0.0695  -0.5511   0.1381   0.1059  -0.5562   0.0011  -0.5628  -0.0342  -0.1565   0.0709  -0.0666\n -0.5216   0.1354   0.1415  -0.0111  -0.2273   0.3423   0.3317  -0.3898  -0.3017   0.39     0.1247\n\nImportance of Components:\n  Cumulative Variance: 0.76  0.9679  0.989  0.9938  0.9968  0.9984  0.9991  0.9995  0.9998  ...  1.0\n  Explained Variance: 0.76  0.2078  0.0212  0.0047  0.0031  0.0016  0.0007  0.0004  0.0002  ...  0.0001","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"If we look at the cumulative variance, we see that we only need to retain the first three principal components to account for 98.9% of the variance in our data. Knowing this, we'll perform a forward rotation with forward_pca, specifying that we want to keep only the first three components.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"transformed = forward_pca(pca, roi, 3)\nr, g, b = [view(transformed, Rasters.Band(i)) for i in 1:3]\nvisualize(r, g, b; upper=0.99)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Each band in the transformed image corresponds to a linear combination of multiple bands from the original image. Thus, the bands no longer relate to wavelengths of light, but instead capture different features from the underlying spectral signatures. In the above visualization, we can see that water is highlighted in yellow, vegetation is green, and built-up land produces hues of bright red. ","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"We may also wish to reverse the transformation in order to recover an approximation of the original image. We can do this with the inverse_pca method, which will return a RasterStack with the same layers as the original image, assuming that it was itself a RasterStack. This makes the recovered image compatible with methods that dispatch on AbstractBandset types, such as visualize.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"recovered = inverse_pca(pca, transformed)\nvisualize(recovered, TrueColor{Sentinel2}; upper=0.99)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"We can see that the color of the recovered image is indeed similar, but not identical to that of the original. Had we elected to retain all 11 components, we would find the two to be identical (minus some floating point error).","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"#RemoteSensingToolbox","page":"Home","title":"RemoteSensingToolbox","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RemoteSensingToolbox is a pure Julia package built on top of Rasters.jl for visualizing, analyzing, and manipulating remotely sensed imagery. Most methods expect either an AbstractRaster or AbstractRasterStack as input and return the same. The most important exception to this rule is visualize, which returns an Array of either Gray or RGB pixels, depending on whether the visualization is intended to be in color or grayscale. The result is that the output of visualize will be automatically displayed inside Pluto. ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RemoteSensingToolbox is a work in progress. This means that new features are being added and existing features are subject to change. To contribute to this project, please create an issue on GitHub or open a pull request.  A summary of both existing and future features are provided below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Feature Description Implemented\nVisualization Visualize images with various band composites Yes\nLand Cover Indices Calculate indices such as MNDWI and NDVI Yes\nQA and SCL Decoding Decode Quality Assurance and Scene Classification masks Yes\nPixel Masking Mask pixels to remove objects such as clouds or shadows Yes\nPCA Perform PCA analysis, transformation, and reconstruction Yes\nMNF Minimum Noise Fraction transformation and reconstruction Yes\nSignature Analysis Visualize spectral signatures for different land cover types Yes\nLand Cover Classification Exposes an MLJ interface for classifying land cover types No\nEndmember Extraction Extract spectral endmembers from an image No\nSpectral Unmixing Perform spectral unmixing under a given endmember library No","category":"page"},{"location":"#Rasters.jl","page":"Home","title":"Rasters.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RemoteSensingToolbox is intended to be used in conjunction with the wider Julia ecosystem and as such, seeks to avoid duplicating functinalities provided by other packages. As the majority of methods accept and return AbstractRaster or AbstractRasterStack objects, users should be able to call methods from Rasters.jl at any point in the processing pipeline. A summary of common functionalities offered by Rasters is provided below: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Description\nmosaic Join rasters covering different extents into a single array or file.\ncrop Shrink objects to specific dimension sizes or the extent of another object.\nextend Extend objects to specific dimension sizes or the extent of another object.\ntrim Trims areas of missing values for arrays and across stack layers.\nresample Resample data to a different size and projection, or snap to another object.\nmask Mask a raster by a polygon or the non-missing values of another Raster.\nreplace_missing Replace all missing values in a raster and update missingval.\nextract Extract raster values from points or geometries.\nzonal Calculate zonal statistics for a raster masked by geometries.","category":"page"},{"location":"#Bandsets","page":"Home","title":"Bandsets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bandsets are Julia types that encode the sensor-specific information needed for many methods in RemoteSensingToolbox to work without the need for tedious details from the end user. Such methods typically expect the sensor type to be passed in as the first argument, which then triggers Julia's multiple dispatch to execute the appropriate sensor-specific procedures. Bandsets are provided for several common sensors including Sentinel-2, Landsat 7, and Landsat 8.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Description\nbands Return the band names in order from shortest to longest wavelength.\nwavelengths Return the central wavelengths for all bands from shortest to longest.\nwavelength Return the central wavelength for the specified band.\nblue Return the blue band for the given sensor.\ngreen Return the green band for the given sensor.\nred Return the red band for the given sensor.\nnir Return the nir band for the given sensor.\nswir1 Return the swir1 band for the given sensor.\nswir2 Return the swir2 band for the given sensor.\nread_bands Read bands from the specified directory into a Raster or RasterStack.\nread_qa Reads the QA or scene classification file from the provided file or directory.\ndn_to_reflectance Decodes digital numbers to reflectance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbstractBandset\nDESIS\nLandsat8\nLandsat7\nSentinel2\nred\ngreen\nblue\nnir\nswir1\nswir2\nbands\nwavelengths\nwavelength\nparse_band\nread_bands\nread_qa\ndn_to_reflectance","category":"page"},{"location":"#RemoteSensingToolbox.Bandsets.AbstractBandset","page":"Home","title":"RemoteSensingToolbox.Bandsets.AbstractBandset","text":"The supertype of all sensor types. Provides sensor-specific information to many RemoteSensingToolbox methods.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.DESIS","page":"Home","title":"RemoteSensingToolbox.Bandsets.DESIS","text":"Implements the AbstractBandset interface for Landsat 7.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.Landsat8","page":"Home","title":"RemoteSensingToolbox.Bandsets.Landsat8","text":"Implements the AbstractBandset interface for Landsat 8.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.Landsat7","page":"Home","title":"RemoteSensingToolbox.Bandsets.Landsat7","text":"Implements the AbstractBandset interface for Landsat 7.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.Sentinel2","page":"Home","title":"RemoteSensingToolbox.Bandsets.Sentinel2","text":"Implements the AbstractBandset interface for Sentinel 2.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.red","page":"Home","title":"RemoteSensingToolbox.Bandsets.red","text":"red(::Type{AbstractBandset})\nred(raster, ::Type{AbstractBandset})\n\nReturn the red band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.green","page":"Home","title":"RemoteSensingToolbox.Bandsets.green","text":"green(::Type{AbstractBandset})\ngreen(raster, ::Type{AbstractBandset})\n\nReturn the green band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.blue","page":"Home","title":"RemoteSensingToolbox.Bandsets.blue","text":"blue(::Type{AbstractBandset})\nblue(raster, ::Type{AbstractBandset})\n\nReturn the blue band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.nir","page":"Home","title":"RemoteSensingToolbox.Bandsets.nir","text":"nir(::Type{AbstractBandset})\nnir(raster, ::Type{AbstractBandset})\n\nReturn the nir band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.swir1","page":"Home","title":"RemoteSensingToolbox.Bandsets.swir1","text":"swir1(::Type{AbstractBandset})\nswir1(raster, ::Type{AbstractBandset})\n\nReturn the swir1 band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.swir2","page":"Home","title":"RemoteSensingToolbox.Bandsets.swir2","text":"swir2(::Type{AbstractBandset})\nswir2(raster, ::Type{AbstractBandset})\n\nReturn the swir2 band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.bands","page":"Home","title":"RemoteSensingToolbox.Bandsets.bands","text":"bands(::Type{AbstractBandset})\n\nReturn the band names in order from shortest to longest wavelength.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.wavelengths","page":"Home","title":"RemoteSensingToolbox.Bandsets.wavelengths","text":"wavelengths(::Type{AbstractBandset})\n\nReturn the central wavelengths for all bands in order from shortest to longest.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.wavelength","page":"Home","title":"RemoteSensingToolbox.Bandsets.wavelength","text":"wavelength(::Type{AbstractBandset}, band::Symbol)\n\nReturn the central wavelength for the corresponding band.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.parse_band","page":"Home","title":"RemoteSensingToolbox.Bandsets.parse_band","text":"parse_band(::Type{AbstractBandset}, filename::String)\n\nParses the band name from the given file path. \n\nReturns either the band as a Symbol or nothing if no band could be parsed.\n\nIf the file is a multi-band raster, returns the names of all bands as a Vector{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.read_bands","page":"Home","title":"RemoteSensingToolbox.Bandsets.read_bands","text":"function read_bands(bandset::Type{AbstractBandset}, dir::String)\n\nRead the bands from the given directory into a RasterStack.\n\nParameters\n\nbandset: The sensor type to which the bands belong.\ndir: The directory in which the bands can be read.\n\nExample\n\njulia> landsat = read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\")\nRasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(493785.0, 728385.0, 7821) ForwardOrdered Regular Points crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(5.84638e6, 5.60878e6, 7921) ReverseOrdered Regular Points crs: WellKnownText\nand 7 layers:\n  :B1 UInt16 dims: X, Y (7821×7921)\n  :B2 UInt16 dims: X, Y (7821×7921)\n  :B3 UInt16 dims: X, Y (7821×7921)\n  :B4 UInt16 dims: X, Y (7821×7921)\n  :B5 UInt16 dims: X, Y (7821×7921)\n  :B6 UInt16 dims: X, Y (7821×7921)\n  :B7 UInt16 dims: X, Y (7821×7921)\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.read_qa","page":"Home","title":"RemoteSensingToolbox.Bandsets.read_qa","text":"read_qa(bandset::Type{AbstractBandSet}, src::String)\n\nRead and decode the quality assurance mask for the given AbstractBandset.\n\nParameters\n\nbandset: A subtype of AbstractBandset.\nsrc: Either a directory containing the quality assurance mask named according to standard conventions or the file itself.\n\nReturns\n\nThe decoded quality assurance mask as a RasterStack. Masked values are encoded as 1, non-masked values as 0, and missing values as 255.\n\nExample\n\njulia> qa = read_qa(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\")\nRasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(493785.0, 728385.0, 7821) ForwardOrdered Regular Points crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(5.84638e6, 5.60878e6, 7921) ReverseOrdered Regular Points crs: WellKnownText\nand 7 layers:\n  :dilated_cloud UInt8 dims: X, Y (7821×7921)\n  :cirrus        UInt8 dims: X, Y (7821×7921)\n  :cloud         UInt8 dims: X, Y (7821×7921)\n  :cloud_shadow  UInt8 dims: X, Y (7821×7921)\n  :snow          UInt8 dims: X, Y (7821×7921)\n  :clear         UInt8 dims: X, Y (7821×7921)\n  :water         UInt8 dims: X, Y (7821×7921)\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.dn_to_reflectance","page":"Home","title":"RemoteSensingToolbox.Bandsets.dn_to_reflectance","text":"dn_to_reflectance(bandset::Type{AbstractBandset}, raster; clamp_values=false)\n\nTransform the raster from Digital Numbers (DN) to reflectance.\n\nParameters\n\nbandset: A subtype of AbstractBandset.\nraster: The AbstractRasterStack or AbstractRaster to be converted to reflectance.\nclamp_values: Indicates whether to clamp reflectances into the range (0.0, 1.0] (default = false).\n\nExample\n\nlandsat = read(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")\nlandsat_sr = dn_to_reflectance(Landsat8, landsat)\n\n\n\n\n\n","category":"function"},{"location":"#Visualization","page":"Home","title":"Visualization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Remotely sensed imagery is typically encoded as either UInt16 or Int16 values. However, many products only actually use the first 12 bits for storing information. The result is that naive visualization methods will produce a near-black image, since the maximum possible brightness will be located in the lower range of values provided by the 16 bit encoding. To address this, we need to perform a linear stretch before visualizing an image. Additionally, many satellites have more than three bands, which motivates the use of band combinations to emphasize certain features and land cover types.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method/Type Description\nTrueColor The true color band combination produces RGB images that are familiar to the human eye.\nAgriculture Used for crop monitoring and emphasizing healthy vegetation.\nGeology Emphasizes geological formations, lithology features, and faults.\nColorInfrared Highlights vegetation in red, water in blue, and urban areas in grey.\nSWIR Emphasizes dense vegetation in dark green and sparse vegetation in lighter shades.\nvisualize Visualize a Raster or RasterStack containing one or more satellite bands.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"visualization.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.Agriculture","page":"Home","title":"RemoteSensingToolbox.Agriculture","text":"Agriculture band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.ColorInfrared","page":"Home","title":"RemoteSensingToolbox.ColorInfrared","text":"Color infrared band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Geology","page":"Home","title":"RemoteSensingToolbox.Geology","text":"Geology band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.SWIR","page":"Home","title":"RemoteSensingToolbox.SWIR","text":"SWIR band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.TrueColor","page":"Home","title":"RemoteSensingToolbox.TrueColor","text":"True color band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.visualize-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.visualize","text":"visualize(g::AbstractRaster; lower=0.02, upper=0.98)\nvisualize(r::AbstractRaster, g::AbstractRaster, b::AbstractRaster; lower=0.02, upper=0.98)\nvisualize(img::AbstractRasterStack, ::Type{TrueColor{AbstractBandset}}; kwargs...)\nvisualize(img::AbstractRasterStack, ::Type{ColorInfrared{AbstractBandset}}; kwargs...)\nvisualize(img::AbstractRasterStack, ::Type{SWIR{AbstractBandset}}; kwargs...)\nvisualize(img::AbstractRasterStack, ::Type{Agriculture{AbstractBandset}}; kwargs...)\nvisualize(img::AbstractRasterStack, ::Type{Geology{AbstractBandset}}; kwargs...)\n\nVisualize a satellite image after applying a histogram stretch. Returns either an RGB or grayscale image compatible with the Images.jl ecosystem.\n\nA number of band combinations are supported for types implementing the AbstractBandSet interface.\n\nExample 1\n\nlandsat = read_bands(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")\nmndwi(landsat, Landsat8) |> visualize\n\nExample 2\n\nlandsat = read_bands(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")\nvisualize(landsat, TrueColor{Landsat8}; upper=0.90)\n\n\n\n\n\n","category":"method"},{"location":"#Land-Cover-Indices","page":"Home","title":"Land Cover Indices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Land cover indices are used to highlight different types of land cover. For example, the Modified Normalized Difference Water Index (MNDWI) is used to highlight water while diminishing built-up areas. Each index is expressed as a function of two or more bands. RemoteSensingToolbox can automatically select the appropriate bands for a given index by providing the Bandset to which the image belongs. Lower-level variants are also provided for manual band selection.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Description\nmndwi The Modified Normalized Difference Index is used to highlight surface water features.\nnbri The Normalized Burn Ratio Index is used to emphasize burned areas.\nndbi The Normalized Difference Built-Up Index is used to empasize urban areas.\nndmi The Normalized Difference Moisture Index is used to monitor droughts and dry areas.\nndvi The Normalized Difference Vegetation Index is used to emphasize vegetation.\nndwi The Normalized Difference Water Index is used to highlight water bodies and vegetation.\nsavi The Soil Adjusted Vegetation Index is an adjusted variant of NDVI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"indices.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.mndwi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.mndwi","text":"mndwi(green::AbstractRaster, swir::AbstractRaster)\nmndwi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Modified Normalised Difference Water Index (Xu 2006).\n\nMNDWI = (green - swir) / (green + swir)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.nbri-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.nbri","text":"nbri(nir::AbstractRaster, swir2::AbstractRaster)\nnbri(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Normalized Burn Ratio Index.\n\nNBRI is used to emphasize burned areas.\n\nNBRI = (nir - swir2) / (nir + swir2)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndbi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndbi","text":"ndbi(swir1::AbstractRaster, nir::AbstractRaster)\nndbi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the The Normalized Difference Built-up Index\n\nNDBI is used to emphasize urban and built-up areas.\n\nNDBI = (swir1 - nir) / (swir1 + nir)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndmi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndmi","text":"ndmi(nir::AbstractRaster, swir1::AbstractRaster)\nndmi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Normalized Difference Moisture Index.\n\nNDMI is sensitive to the moisture levels in vegetation. It is used to monitor droughts and fuel levels in fire-prone areas.\n\nNDMI = (nir - swir1) / (nir + swir1)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndvi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndvi","text":"ndvi(nir::AbstractRaster, red::AbstractRaster)\nndvi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Normalized Difference Vegetation Index.\n\nNDVI = (nir - red) / (nir + red)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndwi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndwi","text":"ndwi(green::AbstractRaster, nir::AbstractRaster)\nndwi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Normalized Difference Water Index (McFeeters 1996).\n\nNDWI = (green - nir) / (green + nir)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.savi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.savi","text":"savi(nir::AbstractRaster, red::AbstractRaster; L=0.33)\nsavi(stack::AbstractRasterStack, ::Type{AbstractBandset}; L=0.33)\n\nCompute the Soil Adjusted Vegetation Index (Huete 1988).\n\nSAVI is a vegetation index which attempts to minimize soil brightness influences by introducing a soil-brightness correction factor (L).\n\nL represents the amount of green vegetation cover, which is set to 0.33 by default.\n\nSAVI = ((nir - red) / (nir + red + L)) * (1 + L)\n\n\n\n\n\n","category":"method"},{"location":"#Spectral-Analysis","page":"Home","title":"Spectral Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spectral analysis involves studying the relationships between different materials and their corresponding spectral signatures. Due to the interactions between light and matter, each signature is unique to the material that emitted it. We can exploit this fact to assign a label to each pixel, or even estimate the abundances of different materials at a sub-pixel level.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Description\nextract_signatures Extract spectral signatures and their corresponding land cover type.\nplot_signatures Plot the spectral signatures for each type of land cover specified in a shapefile.\nplot_signatures! The mutating version of plot_signatures. Writes to a Makie.Axis object.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox.Spectral]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.Spectral.extract_signatures-Tuple{Rasters.AbstractRasterStack, Any, Symbol}","page":"Home","title":"RemoteSensingToolbox.Spectral.extract_signatures","text":"extract_signatures(stack::AbstractRasterStack, shp, label::Symbol; drop_missing=false)\n\nExtract signatures from the given RasterStack within regions specified by a provided shapefile.\n\nParameters\n\nstack: The RasterStack from which to extract spectral signatures.\nshp: A Tables.jl compatible object containing a :geometry column storing a GeoInterface.jl compatible geometry and a label column indicating the land cover type.\nlabel: The column in shp corresponding to the land cover type.\n'drop_missing': Drop all rows with at least one missing value in either the bands or labels (default = true).\n\nReturns\n\nA RasterTable consisting of rows for each observed signature and columns storing the respective bands and land cover type.\n\nExample\n\njulia> landsat = @pipe read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)\n\njulia> shp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame\n\njulia> extract_signatures(landsat, shp, :C_name) |> DataFrame\n1925×8 DataFrame\n  Row │ B1         B2         B3        B4        B5        B6        B7        label     \n      │ Float32    Float32    Float32   Float32   Float32   Float32   Float32   String    \n──────┼───────────────────────────────────────────────────────────────────────────────────\n    1 │ 0.057235   0.10547    0.188932  0.24847   0.513405  0.315323  0.166107  Hail Scar\n    2 │ 0.0574     0.105415   0.188712  0.24946   0.513735  0.317908  0.167593  Hail Scar\n    3 │ 0.0584175  0.107175   0.19182   0.253887  0.515577  0.319585  0.168087  Hail Scar\n    4 │ 0.0583625  0.10723    0.190995  0.253393  0.514615  0.317715  0.167097  Hail Scar\n    5 │ 0.05806    0.10745    0.189895  0.250368  0.50774   0.315048  0.165475  Hail Scar\n  ⋮   │     ⋮          ⋮         ⋮         ⋮         ⋮         ⋮         ⋮          ⋮\n 1921 │ 0.077145   0.112097   0.17081   0.19677   0.25705   0.320877  0.28015   Built Up\n 1922 │ 0.10712    0.136765   0.19666   0.225068  0.268655  0.33284   0.302288  Built Up\n 1923 │ 0.0856425  0.123235   0.185853  0.211675  0.273     0.373623  0.351072  Built Up\n 1924 │ 0.088145   0.119578   0.17059   0.204442  0.27487   0.355857  0.325553  Built Up\n 1925 │ 0.0518725  0.0816275  0.148673  0.15189   0.28774   0.309218  0.29786   Built Up\n                                                                         1915 rows omitted\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.Spectral.plot_signatures!-Tuple{Any, Type{<:AbstractBandset}, Rasters.AbstractRasterStack, Any, Symbol}","page":"Home","title":"RemoteSensingToolbox.Spectral.plot_signatures!","text":"plot_signatures!(ax, bandset::Type{<:AbstractBandset}, raster::AbstractRasterStack, shp, label::Symbol; colors=wong_colors())\n\nPlot spectral signatures for each land cover type specified in a given shapefile by mutating a Makie.Axis object.\n\nAccepts the same keywords as Makie.lines!.\n\nParameters\n\nax: The Makie.Axis into which we want to draw our plot.\nbandset: The sensor type to which the signatures belong.\nraster: A RasterStack from which we want to extract the spectral signatures.\nshp: A Tables.jl compatible object containing a :geometry column storing a GeoInterface.jl compatible geometry and a label column indicating the land cover type.\nlabel: The column in shp corresponding to the land cover type.\ncolors: The color scheme used by the plot.\n\nExample\n\n# Read Images And Convert DNs To Reflectance\nlandsat = @pipe read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)\nsentinel = @pipe read_bands(Sentinel2, \"data/T11UPT_20200804T183919/R60m/\") |> dn_to_reflectance(Sentinel2, _)\n\n# Load Shapefile\nshp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame\n\n# Create Axes\nfig = Figure();\nax1 = Axis(fig[1,1], xlabel=\"Wavelength (nm)\", ylabel=\"Reflectance\", title=\"Landsat Signatures\");\nax2 = Axis(fig[2,1], xlabel=\"Wavelength (nm)\", ylabel=\"Reflectance\", title=\"Sentinel Signatures\");\n\n# Plot Signatures\nplot_signatures!(ax1, Landsat8, landsat, shp, :MC_name; colors=cgrad(:tab10))\nplot_signatures!(ax2, Sentinel2, sentinel, shp, :MC_name; colors=cgrad(:tab10))\n\n# Add Legend\nLegend(fig[:,2], ax1)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.Spectral.plot_signatures-Tuple{Type{<:AbstractBandset}, Rasters.AbstractRasterStack, Any, Symbol}","page":"Home","title":"RemoteSensingToolbox.Spectral.plot_signatures","text":"plot_signatures(bandset::Type{<:AbstractBandset}, raster::AbstractRasterStack, shp, label::Symbol; colors=wong_colors())\n\nPlot the spectral signatures for one or more land cover types.\n\nParameters\n\nbandset: The sensor type to which the signatures belong.\nraster: A RasterStack from which we want to extract the spectral signatures.\nshp: A Tables.jl compatible object containing a :geometry column storing a GeoInterface.jl compatible geometry and a label column indicating the land cover type.\nlabel: The column in shp corresponding to the land cover type.\ncolors: The color scheme used by the plot.\n\nExample\n\n# Read Landsat And Convert DNs To Reflectance\nlandsat = @pipe read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)\n\n# Load Shapefile\nshp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame\n\n# Plot Signatures\nplot_signatures(Landsat8, landsat, shp, :MC_name)\n\n\n\n\n\n","category":"method"},{"location":"#Principal-Component-Analysis","page":"Home","title":"Principal Component Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Principal Component Analysis (PCA) is typically used to reduce the dimensionality of data. In the case of remote sensing, we are interested in reducing the number of bands we need to store while retaining as much information as possible. PCA rotates the bands into a new coordinate space where each band, called a principal component, is orthogonal to and uncorrelated with every other component. By convention, we order the bands in the transformed image in terms of their explained variance, such that the nth component accounts for more variance than any component after it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Description\nfit_pca Fit a PCA transformation to the provided data and return the analytical results.\nforward_pca Run a previously learned PCA transformation on a given Raster or RasterStack.\ninverse_pca Invert a PCA transformation on a previously transformed Raster or RasterStack.\nprojection Return the projection matrix for a fitted PCA transformation.\nexplained_variance Return the explained variance for each component of a fitted PCA transformation.\ncumulative_variance Return the cumulative variance for each component of a fitted PCA transformation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PCA\nfit_pca\nforward_pca\ninverse_pca\nprojection\nexplained_variance\ncumulative_variance","category":"page"},{"location":"#RemoteSensingToolbox.Transformations.PCA","page":"Home","title":"RemoteSensingToolbox.Transformations.PCA","text":"Remotely sensed imagery typically consists of anywhere from a few to several hundred spectral bands. These bands are often highly correlated due to occupying  similar spectral regions. Principal Component Analysis (PCA) is used in remote sensing to:\n\nCreate a smaller dataset from multiple bands, while retaining as much of the original spectral information as possible. The new image will consist of several uncorrelated PC bands.\nReveal complex relationships among spectral features.\nDistinguish between characteristics that are prevalent in most bands and those that are specific to a few.\n\nExample\n\njulia> desis = read_bands(DESIS, \"data/DESIS-HSI-L2A-DT0884573241_001-20200601T234520-V0210/\");\n\njulia> pca = fit_pca(desis, stats_fraction=0.1)\nPCA(dimensions=235) \n\nProjection Matrix:\n235×235 Matrix{Float32}:\n  0.0001  0.0032   0.0016  -0.0094   0.0147  -0.0151  -0.0049   0.0163  …   0.0038  -0.0012   0.0008  -0.0032  -0.0007   0.0053\n  0.0005  0.0099   0.0042  -0.0244   0.0517  -0.0335  -0.0185   0.0441     -0.0023  -0.0016  -0.0008   0.001    0.0003  -0.0004\n  0.0003  0.015    0.0053  -0.037    0.133   -0.0443  -0.0271   0.1381     -0.0006   0.0004   0.0002  -0.0006   0.0003   0.0002\n  0.0003  0.019    0.0071  -0.0385   0.1369  -0.0393  -0.0148   0.0949     -0.0008   0.0006  -0.0001  -0.0006   0.0001  -0.0006\n  0.0003  0.0232   0.0073  -0.0419   0.1469  -0.037    0.0041   0.0839     -0.0013  -0.0025   0.0005   0.0007   0.0007  -0.0002\n  0.0001  0.0267   0.0077  -0.0461   0.1713  -0.0325   0.0246   0.0861  …   0.0013  -0.0007  -0.0007   0.0024  -0.0012  -0.0028\n  0.0001  0.0295   0.0083  -0.0476   0.1695  -0.0348   0.0319   0.0827     -0.0015  -0.0016  -0.0029   0.0004   0.0019  -0.0009\n -0.0001  0.0318   0.0086  -0.0482   0.17    -0.0352   0.0414   0.0784      0.0005  -0.002    0.0003   0.0021  -0.0003  -0.0022\n  ⋮                                           ⋮                         ⋱            ⋮                                  \n -0.0663  0.0371  -0.1728   0.0196  -0.0508  -0.1394  -0.0054  -0.0226     -0.0003   0.0001   0.0007  -0.0009  -0.0002   0.0004\n -0.0658  0.0365  -0.1679   0.0204  -0.0717  -0.1474  -0.0087  -0.0193     -0.0006   0.0002   0.0004  -0.0      0.0004  -0.0001\n -0.0655  0.0352  -0.163    0.0193  -0.0767  -0.1511  -0.012   -0.0232     -0.0005   0.0002  -0.0004  -0.0001  -0.0002   0.0005\n -0.066   0.035   -0.1618   0.0193  -0.0859  -0.1503  -0.0055  -0.0177  …   0.0003   0.0005   0.001   -0.0      0.0003  -0.0002\n -0.067   0.035   -0.1619   0.019   -0.0745  -0.1466   0.0245  -0.0228     -0.0001   0.0002  -0.0002  -0.0001  -0.0002   0.0005\n -0.0679  0.0343  -0.1601   0.0176  -0.0721  -0.139    0.0328  -0.0286      0.0003   0.0003   0.0005  -0.0      0.0003   0.0002\n -0.0682  0.0337  -0.1588   0.0151  -0.0458  -0.1242   0.0549  -0.0315      0.0002  -0.0002  -0.0003   0.0002  -0.0003  -0.0005\n -0.0711  0.0343  -0.1601   0.012   -0.0612  -0.1804   0.2151  -0.0971      0.0004  -0.0001   0.0      0.0003   0.0     -0.0003\n\nImportance of Components:\n  Cumulative Variance: 0.8782  0.9493  0.9809  0.9869  0.9889  0.9906  0.9915  0.9922  0.9928  ...  1.0\n  Explained Variance: 0.8782  0.0711  0.0316  0.006  0.0021  0.0017  0.0009  0.0007  0.0006  ...  0.0\n\njulia> transformed = forward_pca(pca, desis, 12);\n\njulia> size(transformed)\n(1131, 1120, 12)\n\njulia> recovered = inverse_pca(pca, transformed);\n\njulia> size(recovered)\n(1131, 1120, 235)\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Transformations.fit_pca","page":"Home","title":"RemoteSensingToolbox.Transformations.fit_pca","text":"fit_pca(raster; method=:cov, stats_fraction=1.0)\n\nFit a Principal Component Analysis (PCA) transformation to the given AbstractRasterStack or AbstractRaster.\n\nParameters\n\nraster: The AbstractRaster or AbstractRasterStack on which to fit the PCA transformation.\nmethod: Either :cov or :cor, depending on whether we want to use the covariance or correlation matrix for computing the PCA rotation.\nstats_fraction: The fraction of pixels to use when computing the covariance (or correlation) matrix. Values less than 1.0 will speed up computation at the cost of precision.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.forward_pca","page":"Home","title":"RemoteSensingToolbox.Transformations.forward_pca","text":"forward_pca(transformation::PCA, raster, components::Int)\n\nPerform a forward Principal Component Analysis (PCA) transformation on the given raster, retaining only the specified number of components.\n\nParameters\n\ntransformation: A previously fitted PCA transformation.\nraster: The AbstractRaster or AbstractRasterStack on which to perform the PCA transformation.\ncomponents: The number of bands to retain in the transformed image. All band numbers exceeding this value will be discarded.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.inverse_pca","page":"Home","title":"RemoteSensingToolbox.Transformations.inverse_pca","text":"inverse_pca(transformation::PCA, raster::AbstractRaster)\n\nPerform an inverse Principal Component Analysis (PCA) transformation to recover the original image.\n\nParameters\n\ntransformation: A previously fitted PCA transformation.\nraster: An AbstractRaster representing a previously transformed image. The number of bands should be less than or equal to that of the original image.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.projection","page":"Home","title":"RemoteSensingToolbox.Transformations.projection","text":"projection(x::PCA)\n\nReturn the projection matrix for the fitted PCA transformation.\n\n\n\n\n\nprojection(x::MNF)\n\nReturn the projection matrix for the fitted MNF transform.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.explained_variance","page":"Home","title":"RemoteSensingToolbox.Transformations.explained_variance","text":"explained_variance(x::PCA)\n\nReturn the explained variance associated with each principal component of the fitted PCA transform.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.cumulative_variance","page":"Home","title":"RemoteSensingToolbox.Transformations.cumulative_variance","text":"cumulative_variance(x::PCA)\n\nReturn the cumulative variance associated with each principal component of the fitted PCA transform.\n\n\n\n\n\n","category":"function"},{"location":"#Minimum-Noise-Fraction","page":"Home","title":"Minimum Noise Fraction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Minimum Noise Fraction (MNF) transformation is used to separate noise from data along the spectral dimension. This method is typically used with hyperspectral imagery, both as a means of dimension reduction and for noise removal. The transformed image will have its bands placed in descending order according to their Signal to Noise Ratio (SNR). The result is that the noise becomes concentrated in the higher bands, which can then be removed by either applying a standard image denoising algorithm or dropping them altogether.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Description\nfit_mnf Fit an MNF transform to the provided data and return the analytical results.\nforward_mnf Run a previously learned MNF transformation on a given Raster or RasterStack.\ninverse_mnf Invert an MNF transformation on a previously transformed raster.\nnoise_cov Return the noise covariance matrix for a fitted MNF transformation.\ndata_cov Return the data covariance matrix for a fitted MNF transformation.\nsnr Return the SNR for each principal component of a fitted  MNF transformation.\neigenvalues Return eigenvalues for each principal component of a fitted MNF transformation.\ncumulative_snr Return the cumulative SNR for each PC of a fitted MNF transformation.\ncumulative_eigenvalues Return the cumulative eigenvalues for each PC of a fitted MNF transformation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MNF\nfit_mnf\nforward_mnf\ninverse_mnf\nnoise_cov\ndata_cov\nsnr\neigenvalues\ncumulative_snr\ncumulative_eigenvalues","category":"page"},{"location":"#RemoteSensingToolbox.Transformations.MNF","page":"Home","title":"RemoteSensingToolbox.Transformations.MNF","text":"The Minimum Noise Fraction (MNF) transform is a linear transformation used to reduce the spectral dimensionality of image data and  segregate noise. MNF consists of two separate principal component rotations. The first rotation uses the principal components  of the noise covariance matrix to decorrelate and rescale the noise (a process known as noise whitening), resulting in a transformed  image in which the noise has unit variance and no band-to-band correlations. The second rotation is a standard PCA rotation  applied to the noise-whitened image.\n\nThe bands in the transformed image will be ordered according to their Signal to Noise Ratio (SNR), with the highest SNR being  placed first. The result is that the noise becomes concentrated in the higher bands. Thus, the transform can be used to separate  noise from data by performing a forward transform, determining which bands contain coherent images, and running an inverse  transform after either discarding or denoising the remaining bands. The number of bands to keep in the inverse transform can be determined by a number  of methods. The simplest approach is to look at the sorted transformed bands and threshold at the band where no recognizable  features can be observed. An alternative method is to threshold at a desired cumulative SNR.\n\nExample\n\njulia> desis = read_bands(DESIS, \"data/DESIS-HSI-L2A-DT0884573241_001-20200601T234520-V0210/\");\n\njulia> roi = @view desis[X(1019:1040), Y(550:590)];\n\njulia> mnf = fit_mnf(desis, noise_sample=roi)\nMNF(dimensions=235) \n\nProjection Matrix:\n235×235 Matrix{Float32}:\n -2.135    2.3502   0.3612   0.5912   0.5217  -0.0917   0.0043  …   0.0002  -0.0001  -0.0004  -0.0004  -0.0      0.0004\n -0.0959   0.0422  -0.0047  -0.2362  -0.3962  -0.2313  -0.1685      0.0001   0.0004   0.0002   0.0003   0.0001  -0.0001\n  0.0043   0.0058  -0.0032   0.0023  -0.0061  -0.0048   0.0028     -0.0001   0.0001  -0.0001  -0.0      0.0      0.0001\n  0.0039   0.002   -0.002    0.0012  -0.0032  -0.004    0.006      -0.0006   0.0002  -0.0001  -0.0     -0.0003  -0.0\n  0.0024   0.0018  -0.003   -0.0008   0.0038  -0.0003   0.0057      0.0009  -0.0007   0.0002  -0.0012   0.0012  -0.0\n  0.0019  -0.003    0.0038  -0.002   -0.0001  -0.0003  -0.0     …   0.0021   0.0009  -0.0004   0.0014  -0.0011  -0.0006\n  0.0047   0.0055   0.006   -0.0014  -0.0011   0.0021   0.0053     -0.0035   0.0006   0.0002  -0.0026   0.0014   0.0019\n  0.0072   0.0042   0.0012   0.0016   0.0011  -0.002   -0.001       0.0     -0.0026   0.0012   0.0034  -0.0006  -0.0009\n  ⋮                                            ⋮                ⋱            ⋮                                  \n -0.0004  -0.0012   0.0007   0.0006  -0.0      0.0002   0.0005      0.0005   0.0002  -0.0004  -0.0002  -0.0001   0.0001\n -0.0014  -0.0005  -0.0005   0.0019  -0.0002  -0.0005   0.0017      0.0003   0.0005   0.0      0.0004   0.0005   0.0\n -0.0004   0.0008  -0.0003   0.0013   0.0004   0.0014   0.0004      0.0002  -0.0001   0.0002   0.0001  -0.0002  -0.0002\n -0.0008  -0.0015   0.0021  -0.0004  -0.0004   0.0012   0.0006  …  -0.0011   0.0002  -0.0007   0.0001   0.0005  -0.0001\n  0.0008  -0.0004   0.0009   0.0019  -0.0022  -0.0014   0.0013      0.0003  -0.0001  -0.0003  -0.0      0.0003   0.0002\n  0.0005   0.0006  -0.0022  -0.0003   0.0     -0.0022   0.0016     -0.001    0.0002  -0.0003   0.0003  -0.0005   0.0005\n  0.001   -0.0005  -0.0007   0.0025  -0.0019   0.0005   0.0015      0.0002  -0.0005   0.0     -0.0005   0.0002  -0.0002\n -0.0003   0.0002  -0.0021  -0.0008  -0.0012   0.0003   0.0003     -0.0001  -0.0      0.0001   0.0      0.0      0.0\n\nComponent Statistics:\n  Eigenvalues: 7975.439  4040.6348  2092.866  717.8178  468.5496  247.5029  202.2003  176.8452  87.3302  ...  0.3602\n  Cumulative Eigenvalues: 0.4779  0.72  0.8454  0.8884  0.9165  0.9313  0.9434  0.954  0.9593  ...  1.0\n  Explained SNR: 7974.4385  4039.6353  2091.8635  716.8176  467.55  246.5022  201.1985  175.845  86.3301  ...  -0.6399\n  Cumulative SNR: 0.4839  0.729  0.856  0.8995  0.9278  0.9428  0.955  0.9657  0.9709  ...  0.9985\n\njulia> transformed = forward_mnf(mnf, desis, 12);\n\njulia> size(transformed)\n(1131, 1120, 12)\n\njulia> recovered = inverse_mnf(mnf, transformed);\n\njulia> size(recovered)\n(1131, 1120, 235)\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Transformations.fit_mnf","page":"Home","title":"RemoteSensingToolbox.Transformations.fit_mnf","text":"fit_mnf(raster; noise_sample=raster, smooth=true)\n\nFit a Minimum Noise Fraction (MNF) transformation to the given AbstractRasterStack or AbstractRaster.\n\nParameters\n\nraster: The AbstractRaster or AbstractRasterStack on which to fit the MNF transformation.\nnoise_sample: A homogenous (spectrally uniform) region extracted from raster for calculating the noise covariance matrix.\nsmooth: The MNF transform cannot be computed if any band in noise_sample has zero variance. To correct this, you may wish to introduce a small smoothing term (false by default).\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.forward_mnf","page":"Home","title":"RemoteSensingToolbox.Transformations.forward_mnf","text":"forward_mnf(transformation::MNF, raster, components::Int)\n\nPerform a forward Minimum Noise Fraction (MNF) rotation on the given raster, retaining only the specified number of components.\n\nParameters\n\ntransformation: A previously fitted MNF transformation.\nraster: The AbstractRaster or AbstractRasterStack on which to perform the MNF transformation.\ncomponents: The number of bands to retain in the transformed image. All band numbers exceeding this value will be discarded.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.inverse_mnf","page":"Home","title":"RemoteSensingToolbox.Transformations.inverse_mnf","text":"inverse_mnf(transformation::MNF, raster::AbstractRaster)\n\nPerform an inverse Minimum Noise Fraction (MNF) transformation to recover the original image.\n\nParameters\n\ntransformation: A previously fitted MNF transformation.\nraster: An AbstractRaster representing a previously transformed image. The number of bands should be less than or equal to that of the original image.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.noise_cov","page":"Home","title":"RemoteSensingToolbox.Transformations.noise_cov","text":"noise_cov(x::MNF)\n\nReturn the noise covariance matrix for the fitted MNF transform.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.data_cov","page":"Home","title":"RemoteSensingToolbox.Transformations.data_cov","text":"data_cov(x::MNF)\n\nReturn the data covariance matrix for the fitted MNF transform.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.snr","page":"Home","title":"RemoteSensingToolbox.Transformations.snr","text":"snr(x::MNF)\n\nReturn the estimated SNR associated with each principal components of the fitted MNF transform.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.eigenvalues","page":"Home","title":"RemoteSensingToolbox.Transformations.eigenvalues","text":"eigenvalues(x::MNF)\n\nReturn the eigenvalues associated with each principal components of the fitted MNF transform.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.cumulative_snr","page":"Home","title":"RemoteSensingToolbox.Transformations.cumulative_snr","text":"cumulative_snr(x::MNF)\n\nReturn the cumulative SNR associated with each principal components of the fitted MNF transform.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Transformations.cumulative_eigenvalues","page":"Home","title":"RemoteSensingToolbox.Transformations.cumulative_eigenvalues","text":"cumulative_eigenvalues(x::MNF)\n\nReturn the cumulative eigenvalues associated with each principal components of the fitted MNF transform.\n\n\n\n\n\n","category":"function"},{"location":"#Utilities","page":"Home","title":"Utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RemoteSensingToolbox provides several utility functions for modifying and processing remotely sensed data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Description\nmask_pixels Remove all pixels in a raster covered by a provided mask.\nmask_pixels! The mutating form of mask_pixels.\ntocube Convert a multi-layer RasterStack into a multiband Raster.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"preprocessing.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.create_tiles-Tuple{Any, Tuple{Int64, Int64}}","page":"Home","title":"RemoteSensingToolbox.create_tiles","text":"create_tiles(raster, tile::Tuple{Int,Int}; stride=tile)\n\nSlice the given raster into tiles with size tile.\n\nParameters\n\nraster: The raster to be cut into tiles.\ntile: The size of the generated tiles in terms of width x height.\nstride: The distance between the top-left corner of each tile. Is equal to tile by default, which produces non-overlapping tiles.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.mask_pixels!-Tuple{Rasters.AbstractRaster, Any}","page":"Home","title":"RemoteSensingToolbox.mask_pixels!","text":"mask_pixels!(raster, mask; invert_mask=false)\n\nDrop pixels from a raster according to a given mask. The mask and raster must have the same extent and size.\n\nParameters\n\nraster: The raster to be masked.\nmask: A mask defining which pixels we want to drop. By default, we drop pixels corresponding to mask values of 1.\ninvert_mask: Treat mask values of 1 as 0 and vice-versa.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.mask_pixels-Tuple{Rasters.AbstractRaster, Any}","page":"Home","title":"RemoteSensingToolbox.mask_pixels","text":"mask_pixels(raster, mask; invert_mask=false)\n\nDrop pixels from a raster according to a given mask. The mask and raster must have the same extent and size.\n\nParameters\n\nraster: The raster to be masked.\nmask: A mask defining which pixels we want to drop. By default, we drop pixels corresponding to mask values of 1.\ninvert_mask: Treat mask values of 1 as 0 and vice-versa.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.tocube-Tuple{Rasters.RasterStack}","page":"Home","title":"RemoteSensingToolbox.tocube","text":"tocube(rs::RasterStack; layers=names(rs))\ntocube(rs::AbstractBandset; layers=names(rs))\n\nTransform the multi-layer RasterStack to a multi-band raster.\n\nParameters\n\nX: The RasterStack or AbstractBandset to be transformed into a multi-band raster.\nlayers: The layers to include in the new raster.\n\nExample\n\njulia> landsat = read_bands(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\");\n\njulia> tocube(landsat)\n7821×7921×7 Raster{Float32,3} B1 with dimensions: \n  X Projected{Float64} LinRange{Float64}(493785.0, 728385.0, 7821) ForwardOrdered Regular Points crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(5.84638e6, 5.60878e6, 7921) ReverseOrdered Regular Points crs: WellKnownText,\n  Band Categorical{Int64} 1:7 ForwardOrdered\nextent: Extent(X = (493785.0, 728385.0), Y = (5.608785e6, 5.846385e6), Band = (1, 7))\nmissingval: 0.0f0\ncrs: PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]\nparent:\n[:, :, 1]\n           5.84638e6  5.84636e6  5.84632e6  5.8463e6  5.84626e6  …  5.60894e6  5.6089e6  5.60888e6  5.60884e6  5.60882e6  5.60878e6\n 493785.0  0.0        0.0        0.0        0.0       0.0           0.0        0.0       0.0        0.0        0.0        0.0\n      ⋮                                               ⋮          ⋱                                             ⋮          \n 728355.0  0.0        0.0        0.0        0.0       0.0           0.0        0.0       0.0        0.0        0.0        0.0\n 728385.0  0.0        0.0        0.0        0.0       0.0           0.0        0.0       0.0        0.0        0.0        0.0\n[and 6 more slices...]\n\n\n\n\n\n","category":"method"}]
}

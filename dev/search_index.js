var documenterSearchIndex = {"docs":
[{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"RemoteSensingToolbox provides a number of utilities for visualizing, manipulating, and interpreting remotely sensed imagery. First, lets load the imagery we want to work with. We're using Landsat 8 imagery in this example, so we'll pass the Landsat8 type to read_bands so it knows how to parse the relevant files from the provided directory. Landsat8 is an instance of AbstractBandset, which is the supertype responsible for allowing many methods within RemoteSensingToolbox to infer sensor-specific information by exploiting Julia's multiple dispatch system.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using RemoteSensingToolbox, Rasters\nusing Pipe: @pipe\n\nlandsat = read_bands(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now let's visualize our data to see what we're working with. This is where the power of AbstractBandset can first be demonstrated. To view a true color composite of the data, we need to know the bands corresponding to red, green, and blue. However, it would be tedious to memorize and manually specify this information whenever we want to call a method which relies on a specific combination of bands. Fortunately, all AbstractBandset types know this information implicitly, so all we need to do is pass in Landsat8 as a parameter to TrueColor.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"visualize(landsat, TrueColor{Landsat8}; upper=0.90)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"You may have noticed that we provided an additional argument upper to the visualize method. This parameter controls the upper quantile to be used when performing histogram stretching to make the imagery interpretable to humans. This parameter is set to 0.98 by default, but because our scene contains a significant number of bright clouds, we need to lower it to prevent the image from appearing too dark. We can remove these clouds by first loading the Quality Assurance (QA) mask that came with our landsat product and then calling mask_pixels.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"qa = read_qa(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")\n\nmasked_landsat = @pipe mask_pixels(landsat, qa[:cloud]) |> mask_pixels(_, qa[:cloud_shadow])\n\nvisualize(masked_landsat, TrueColor{Landsat8})","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Now let's try to visualize some other band combinations. The Agriculture band comination is commonly used to distinguish regions with healthy vegetation, which appear as various shades of green.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"visualize(landsat, Agriculture{Landsat8}; upper=0.90)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"We can also convert Digital Numbers (DNs) to reflectance by calling dn_to_reflectance and passing in the appropriate bandset.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"landsat_sr = dn_to_reflectance(Landsat8, landsat)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"We'll finish this example by demonstrating how to compute land cover indices with any AbstractBandset type. The Modified Normalized Difference Water Index (MNDWI) is used to help distinguish water from land. Here, we visualize both the true color representation and the corresponding MNDWI index.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"roi = @view landsat_sr[X(5800:6800), Y(2200:3200)]\n\ntrue_color = visualize(roi, TrueColor{Landsat8}; upper=0.998)\n\nindex = mndwi(roi, Landsat8) |> visualize\n\nmosaicview(true_color, index; npad=5, fillvalue=0.0, ncol=2)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"spectral_example/#Spectral-Analysis","page":"Spectral Analysis","title":"Spectral Analysis","text":"","category":"section"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"A common application of remotely sensed imagery is land cover classification. One method to accomplish this is to analyze the spectral signatures produced by different types of cover. RemoteSensingToolbox provides a number of functions for extracting and visualyzing spectral signatures organized by their associated lan cover.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"The first step in our analysis is to load our remotely sensed data and convert the DNs (Digital Numbers) to reflectances. Reflectance is a standardized unit of measurement defined over the interval [0, 1] which denotes the fraction of light that is reflected by the observed surface. A reflectance of 0.0 indicates that no light was reflected whereas a reflectance of 1.0 indicates that 100% of light was reflected.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"using RemoteSensingToolbox, DataFrames, Shapefile, CairoMakie\nusing Pipe: @pipe\n\nlandsat = @pipe Landsat8(\"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"Next, we need to load a shapefile which defines some regions containing each type of land cover that we're interested in.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"shp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"Examining the shapefile gives us some idea of how its contents are structured. As we can see, the regions of interest are stored as Polygon objects under the :geometry column, while the land cover types are under :MC_name and :C_name. The :MC_name column defines the macroclass, which in our case are built up land, vegetation, bare earth, and water. The :C_name column defines the specific class to which some land cover belongs. For example, both \"Trees\" and \"Vegetation\" belong to the \"Vegetation\" macroclass.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"8×7 DataFrame\n Row │ geometry            fid      MC_ID  MC_name     C_ID   C_name      SCP_UID                   \n     │ Polygon             Missing  Int64  String      Int64  String      String                    \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Polygon(38 Points)  missing      1  Built Up        1  Built Up    20230527_122212594060_314\n   2 │ Polygon(31 Points)  missing      1  Built Up        2  Road        20230527_122301732906_304\n   3 │ Polygon(7 Points)   missing      2  Vegetation      3  Vegetation  20230527_122832068862_302\n   4 │ Polygon(57 Points)  missing      2  Vegetation      4  Trees       20230527_123221462871_572\n   5 │ Polygon(5 Points)   missing      3  Bare Earth      5  Hail Scar   20230527_123631491671_937\n   6 │ Polygon(7 Points)   missing      3  Bare Earth      6  Bare Earth  20230527_123727873290_779\n   7 │ Polygon(7 Points)   missing      4  Water           7  Lake        20230527_123931189139_867\n   8 │ Polygon(5 Points)   missing      3  Bare Earth      6  Bare Earth  20230527_125120033074_286","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"We can extract the signatures inside each polygon with extract_signatures, then compute the average of each land cover class with summarize_signatures.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"sigs = extract_signatures(landsat, shp, :C_name) |> summarize_signatures","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"7×8 DataFrame\n Row │ label       B1           B2          B3         B4          B5        B6          B7         \n     │ String      Float32      Float32     Float32    Float32     Float32   Float32     Float32    \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Hail Scar   0.0617346    0.107954    0.188092   0.247114    0.508847  0.322815    0.173574\n   2 │ Bare Earth  0.0483927    0.0539072   0.0773476  0.0883738   0.231219  0.307681    0.199805\n   3 │ Road        0.0396956    0.0530674   0.0933762  0.0952315   0.245672  0.205506    0.142639\n   4 │ Lake        0.000517442  0.00360272  0.0132789  0.00628491  0.031176  0.00697667  0.00377249\n   5 │ Trees       0.0182846    0.0204864   0.0404257  0.0245542   0.319328  0.139772    0.0585171\n   6 │ Vegetation  0.00442494   0.015797    0.0789011  0.0464686   0.49601   0.0964562   0.0407997\n   7 │ Built Up    0.0892711    0.118764    0.177746   0.200785    0.293111  0.33917     0.304133","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"Finally, we can visualize the signatures as a line graph with plot_signatures.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"plot_signatures(Landsat8, sigs)","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"(Image: )","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"We see that we've plotted the signatures for each land cover type in shp. However, we may wish to override the default colors. Fortunately, plot_signatures accepts an optional argument allowing us to specify any colors that we wish.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"plot_signatures(Landsat8, sigs; colors=cgrad(:tab10))","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"(Image: )","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"The plot_signatures! method is nearly identical to plot_signatures, but it expects a Makie.Axis object as its first argument onto which the signatures will be drawn (hence the exclamation). This allows us to create more complicated plots than are supported by plot_signatures. We will demonstrate this capability by plotting the same signatures for three different sensors, each of which passed over our study area within a period of four days. For this reason, we can compare the signatures with a single shapefile, as we do not expect the land cover types to change significantly within this span of time.","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"# Load Sentinel and DESIS\nsentinel = @pipe read_bands(Sentinel2, \"data/T11UPT_20200804T183919/R60m/\") |> dn_to_reflectance(Sentinel2, _)\ndesis = @pipe read_bands(DESIS, \"data/DESIS-HSI-L2A-DT0884573241_001-20200601T234520-V0210\") |> dn_to_reflectance(DESIS, _)\nsensors = [landsat, sentinel, desis]\n\n# Create Figure\nfig = Figure(resolution=(1000, 800))\n\n# Create Axes\nax1 = Axis(fig[1,1], title=\"Landsat 8\", xticksvisible=false, xticklabelsvisible=false)\nax2 = Axis(fig[2,1], title=\"Sentinel 2\", ylabel=\"Reflectance\", ylabelfont=:bold, xticksvisible=false, xticklabelsvisible=false)\nax3 = Axis(fig[3,1], title=\"DESIS\", xlabel=\"Wavelength (nm)\", xlabelfont=:bold)\naxs = [ax1, ax2, ax3]\n\n# Plot Signatures\ncolors = cgrad([:saddlebrown, :orange, :navy, :green], 4, categorical=true)\nfor (bandset, sensor, ax) in zip((Landsat8, Sentinel2, DESIS), sensors, axs)\n   @pipe extract_signatures(sensor, shp, :MC_name) |> summarize_signatures |> plot_signatures!(ax, bandset, _; colors=colors)\n   xlims!(ax, 400, 1000)\nend\n\n# Add Legend\nLegend(fig[1:3,2], first(axs), \"Classification\")","category":"page"},{"location":"spectral_example/","page":"Spectral Analysis","title":"Spectral Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"pca_example/#Principal-Component-Analysis","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"","category":"section"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Remotely sensed imagery typically consists of anywhere from five to several hundred spectral bands. These bands are often highly correlated because they occupy similar spectral regions. ","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"PCA is used in remote sensing to:","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Create a smaller dataset from multiple bands, while retaining as much of the original spectral information as possible. The new image will consist of several uncorrelated PC bands.\nReveal complex relationships among spectral features.\nDetermine which characteristics are prevalent in most of the bands, and those that are specific to only a few.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Our first step is to load and visualize our initial image.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"using RemoteSensingToolbox, Rasters\nusing Pipe: @pipe\n\nsentinel = read_bands(Sentinel2, \"data/T11UPT_20200804T183919/R60m/\")\nroi = @view sentinel[Rasters.X(900:1799), Rasters.Y(1:900)]\nvisualize(roi, TrueColor{Sentinel2}; upper=0.99)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Next, we'll fit a PCA transformation to our image. The reason that we make fitting and transformation seperate is so that the procedure can be repeated and reversed. We'll try keeping all of the components at first so we can get a sense of how many we'll need to retain. ","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"pca_full = fit_transform(PCA, sentinel, method=:cov)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"PCA(in_dim=11, out_dim=11, explained_variance=1.0)\n\nProjection Matrix:\n11×11 Matrix{Float64}:\n -0.026   -0.2068  -0.359    0.312   -0.0955  -0.4791   0.2245  -0.6117   0.1862  -0.1494   0.1005\n -0.0361  -0.2354  -0.3739   0.1417  -0.0495  -0.1544   0.3841   0.3908  -0.3467   0.2438  -0.5265\n -0.0775  -0.2406  -0.3554  -0.1492   0.0607   0.0575   0.0611   0.2326  -0.4335  -0.2812   0.6751\n -0.0396  -0.3231  -0.321   -0.0301  -0.048    0.4006   0.1103   0.1691   0.6681   0.3318   0.1738\n -0.1194  -0.2914  -0.2233  -0.3824   0.3987   0.3538  -0.1552  -0.388   -0.0944  -0.2647  -0.4087\n -0.3925   0.0354  -0.0791  -0.5717   0.1024  -0.5641  -0.2124   0.0649   0.1101   0.3449   0.0496\n -0.4949   0.1513  -0.0179  -0.1062  -0.4124   0.0178   0.1554   0.231    0.257   -0.6108  -0.1833\n -0.5257   0.084   -0.0977   0.6026   0.4321   0.0232  -0.3684   0.1418   0.0193   0.0173   0.0145\n -0.155   -0.549    0.63     0.0248   0.3084  -0.1466   0.361    0.095    0.0889  -0.0983   0.0592\n -0.0695  -0.5511   0.1381   0.1059  -0.5562   0.0011  -0.5628  -0.0342  -0.1565   0.0709  -0.0666\n -0.5216   0.1354   0.1415  -0.0111  -0.2273   0.3423   0.3317  -0.3898  -0.3017   0.39     0.1247\n\nImportance of Components:\n  Cumulative Variance: 0.76  0.9679  0.989  0.9938  0.9968  0.9984  0.9991  0.9995  0.9998  0.9999  1.0\n  Explained Variance: 0.76  0.2078  0.0212  0.0047  0.0031  0.0016  0.0007  0.0004  0.0002  0.0002  0.0001","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"If we look at the cumulative variance, we see that we only need to retain three principal components to account for 98.9% of the variance in our data. Knowing this, let's try again with only three components.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"pca = fit_transform(PCA, sentinel, components=3)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"PCA(in_dim=11, out_dim=3, explained_variance=0.989)\n\nProjection Matrix:\n11×3 Matrix{Float64}:\n -0.026   -0.2068  -0.359\n -0.0361  -0.2354  -0.3739\n -0.0775  -0.2406  -0.3554\n -0.0396  -0.3231  -0.321\n -0.1194  -0.2914  -0.2233\n -0.3925   0.0354  -0.0791\n -0.4949   0.1513  -0.0179\n -0.5257   0.084   -0.0977\n -0.155   -0.549    0.63\n -0.0695  -0.5511   0.1381\n -0.5216   0.1354   0.1415\n\nImportance of Components:\n  Cumulative Variance: 0.76  0.9679  0.989\n  Explained Variance: 0.76  0.2078  0.0212","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Now we can perform the learned PCA transformation on our image and visualize the results.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"transformed = transform(pca, roi)\nr, g, b = [view(transformed, Rasters.Band(i)) for i in 1:3]\nvisualize(r, g, b; upper=0.99)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"Each band in the transformed image corresponds to a linear combination of multiple bands from the original image. Thus, the bands no longer relate to wavelengths of light, but instead capture different features from the underlying spectral signatures. In the above image, we can see that water is highlighted in yellow, vegetation is green, and built-up land produces hues of bright red. Thus, we have managed to retain the majority of spectral information while reducing the number of bands from 11 to 3.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"We may also wish to reverse the transformation in order to recover an approximation of the original image. We can do this with the inverse_transform method, which will return a RasterStack with the same layers as the original image, assuming that it was itself a RasterStack. This makes the recovered image compatible with methods that dispatch on AbstractBandset types, such as visualize.","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"recovered = inverse_transform(pca, transformed)\nvisualize(recovered, TrueColor{Sentinel2}; upper=0.99)","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"(Image: )","category":"page"},{"location":"pca_example/","page":"Principal Component Analysis","title":"Principal Component Analysis","text":"We can see that the color of the recovered image is indeed similar, but not identical to that of the original. Had we elected to retain all 11 components, we would find the two to be identical (minus some floating point error).","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RemoteSensingToolbox","category":"page"},{"location":"#RemoteSensingToolbox","page":"Home","title":"RemoteSensingToolbox","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RemoteSensingToolbox is a pure Julia package intended to provide a collection of tools for visualizing, manipulating, and interpreting remotely sensed imagery.","category":"page"},{"location":"#Bandsets","page":"Home","title":"Bandsets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bandsets are julia types that encode the sensor-specific information needed for many methods in RemoteSensingToolbox to work without the need for tedious details provided by the end user. Bandsets are provided for several common sensors including Sentinel-2, Landsat 7, and Landsat 8. Unsupported sensors can be added by defining a custom type, which should be a sub-type of AbstractBandset, and implementing the following interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Method Description Required\nbands Return the band names in order from shortest to longest wavelength. yes\nwavelengths Return the central wavelengths for all bands from shortest to longest. yes\nblue Return the blue band for the given sensor. yes\ngreen Return the green band for the given sensor. yes\nred Return the red band for the given sensor. yes\nnir Return the nir band for the given sensor. yes\nswir1 Return the swir1 band for the given sensor. yes\nswir2 Return the swir2 band for the given sensor. yes\nparse_band Parses the band from a given filename. Used by read_bands. no\nread_qa Reads the QA or scene classification file from the provided file or directory. no\ndn_to_reflectance Decodes digital numbers to reflectance. no","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbstractBandset\nDESIS\nLandsat8\nLandsat7\nSentinel2\nred\ngreen\nblue\nnir\nswir1\nswir2\nbands\nwavelengths\nwavelength\nparse_band\nread_bands\nread_qa\ndn_to_reflectance","category":"page"},{"location":"#RemoteSensingToolbox.Bandsets.AbstractBandset","page":"Home","title":"RemoteSensingToolbox.Bandsets.AbstractBandset","text":"The supertype of all sensor types. Provides sensor-specific information to many RemoteSensingToolbox methods.\n\nExample Minimal Implementation\n\nstruct Landsat8 <: AbstractBandset end\n\nbands(::Type{Landsat8}) = [:B1, :B2, :B3, :B4, :B5, :B6, :B7]\n\nwavelengths(::Type{Landsat8}) = [443, 483, 560, 660, 865, 1650, 2220]\n\nblue(::Type{Landsat8}) = :B2\n\ngreen(::Type{Landsat8}) = :B3\n\nred(::Type{Landsat8}) = :B4\n\nnir(::Type{Landsat8}) = :B5\n\nswir1(::Type{Landsat8}) = :B6\n\nswir2(::Type{Landsat8}) = :B7\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.DESIS","page":"Home","title":"RemoteSensingToolbox.Bandsets.DESIS","text":"Implements the AbstractBandset interface for Landsat 7.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.Landsat8","page":"Home","title":"RemoteSensingToolbox.Bandsets.Landsat8","text":"Implements the AbstractBandset interface for Landsat 8.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.Landsat7","page":"Home","title":"RemoteSensingToolbox.Bandsets.Landsat7","text":"Implements the AbstractBandset interface for Landsat 7.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.Sentinel2","page":"Home","title":"RemoteSensingToolbox.Bandsets.Sentinel2","text":"Implements the AbstractBandset interface for Sentinel 2.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Bandsets.red","page":"Home","title":"RemoteSensingToolbox.Bandsets.red","text":"red(::Type{AbstractBandset})\nred(raster, ::Type{AbstractBandset})\n\nReturn the red band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.green","page":"Home","title":"RemoteSensingToolbox.Bandsets.green","text":"green(::Type{AbstractBandset})\ngreen(raster, ::Type{AbstractBandset})\n\nReturn the green band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.blue","page":"Home","title":"RemoteSensingToolbox.Bandsets.blue","text":"blue(::Type{AbstractBandset})\nblue(raster, ::Type{AbstractBandset})\n\nReturn the blue band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.nir","page":"Home","title":"RemoteSensingToolbox.Bandsets.nir","text":"nir(::Type{AbstractBandset})\nnir(raster, ::Type{AbstractBandset})\n\nReturn the nir band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.swir1","page":"Home","title":"RemoteSensingToolbox.Bandsets.swir1","text":"swir1(::Type{AbstractBandset})\nswir1(raster, ::Type{AbstractBandset})\n\nReturn the swir1 band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.swir2","page":"Home","title":"RemoteSensingToolbox.Bandsets.swir2","text":"swir2(::Type{AbstractBandset})\nswir2(raster, ::Type{AbstractBandset})\n\nReturn the swir2 band for the given sensor.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.bands","page":"Home","title":"RemoteSensingToolbox.Bandsets.bands","text":"bands(::Type{AbstractBandset})\n\nReturn the band names in order from shortest to longest wavelength.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.wavelengths","page":"Home","title":"RemoteSensingToolbox.Bandsets.wavelengths","text":"wavelengths(::Type{AbstractBandset})\n\nReturn the central wavelengths for all bands in order from shortest to longest.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.wavelength","page":"Home","title":"RemoteSensingToolbox.Bandsets.wavelength","text":"wavelength(::Type{AbstractBandset}, band::Symbol)\n\nReturn the central wavelength for the corresponding band.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.parse_band","page":"Home","title":"RemoteSensingToolbox.Bandsets.parse_band","text":"parse_band(::Type{AbstractBandset}, filename::String)\n\nParses the band name from the given file path. \n\nReturns either the band as a Symbol or nothing if no band could be parsed.\n\nIf the file is a multi-band raster, returns the names of all bands as a Vector{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.read_bands","page":"Home","title":"RemoteSensingToolbox.Bandsets.read_bands","text":"function read_bands(bandset::Type{AbstractBandset}, dir::String)\n\nRead the bands from the given directory into a RasterStack.\n\nParameters\n\nbandset: The sensor type to which the bands belong.\ndir: The directory in which the bands can be read.\n\nExample\n\njulia> landsat = read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\")\nRasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(493785.0, 728385.0, 7821) ForwardOrdered Regular Points crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(5.84638e6, 5.60878e6, 7921) ReverseOrdered Regular Points crs: WellKnownText\nand 7 layers:\n  :B1 UInt16 dims: X, Y (7821×7921)\n  :B2 UInt16 dims: X, Y (7821×7921)\n  :B3 UInt16 dims: X, Y (7821×7921)\n  :B4 UInt16 dims: X, Y (7821×7921)\n  :B5 UInt16 dims: X, Y (7821×7921)\n  :B6 UInt16 dims: X, Y (7821×7921)\n  :B7 UInt16 dims: X, Y (7821×7921)\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.read_qa","page":"Home","title":"RemoteSensingToolbox.Bandsets.read_qa","text":"read_qa(bandset::Type{AbstractBandSet}, src::String)\n\nRead and decode the quality assurance mask for the given AbstractBandset.\n\nParameters\n\nbandset: A subtype of AbstractBandset.\nsrc: Either a directory containing the quality assurance mask named according to standard conventions or the file itself.\n\nReturns\n\nThe decoded quality assurance mask as a RasterStack. Masked values are encoded as 1, non-masked values as 0, and missing values as 255.\n\nExample\n\njulia> qa = read_qa(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\")\nRasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(493785.0, 728385.0, 7821) ForwardOrdered Regular Points crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(5.84638e6, 5.60878e6, 7921) ReverseOrdered Regular Points crs: WellKnownText\nand 7 layers:\n  :dilated_cloud UInt8 dims: X, Y (7821×7921)\n  :cirrus        UInt8 dims: X, Y (7821×7921)\n  :cloud         UInt8 dims: X, Y (7821×7921)\n  :cloud_shadow  UInt8 dims: X, Y (7821×7921)\n  :snow          UInt8 dims: X, Y (7821×7921)\n  :clear         UInt8 dims: X, Y (7821×7921)\n  :water         UInt8 dims: X, Y (7821×7921)\n\n\n\n\n\n","category":"function"},{"location":"#RemoteSensingToolbox.Bandsets.dn_to_reflectance","page":"Home","title":"RemoteSensingToolbox.Bandsets.dn_to_reflectance","text":"dn_to_reflectance(bandset::Type{AbstractBandset}, raster; clamp_values=false)\n\nTransform the raster from Digital Numbers (DN) to reflectance.\n\nParameters\n\nbandset: A subtype of AbstractBandset.\nraster: The AbstractRasterStack or AbstractRaster to be converted to reflectance.\nclamp_values: Indicates whether to clamp reflectances into the range (0.0, 1.0] (default = false).\n\nExample\n\nlandsat = read(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")\nlandsat_sr = dn_to_reflectance(Landsat8, landsat)\n\n\n\n\n\n","category":"function"},{"location":"#Visualization","page":"Home","title":"Visualization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"visualization.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.Agriculture","page":"Home","title":"RemoteSensingToolbox.Agriculture","text":"Agriculture band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.ColorInfrared","page":"Home","title":"RemoteSensingToolbox.ColorInfrared","text":"Color infrared band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Geology","page":"Home","title":"RemoteSensingToolbox.Geology","text":"Geology band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.SWIR","page":"Home","title":"RemoteSensingToolbox.SWIR","text":"SWIR band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.TrueColor","page":"Home","title":"RemoteSensingToolbox.TrueColor","text":"True color band composite.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.visualize-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.visualize","text":"visualize(g::AbstractRaster; lower=0.02, upper=0.98)\nvisualize(r::AbstractRaster, g::AbstractRaster, b::AbstractRaster; lower=0.02, upper=0.98)\nvisualize(img::AbstractBandSet, ::Type{TrueColor{AbstractBandset}}; kwargs...)\nvisualize(img::AbstractBandSet, ::Type{ColorInfrared{AbstractBandset}}; kwargs...)\nvisualize(img::AbstractBandSet, ::Type{SWIR{AbstractBandset}}; kwargs...)\nvisualize(img::AbstractBandSet, ::Type{Agriculture{AbstractBandset}}; kwargs...)\nvisualize(img::AbstractBandSet, ::Type{Geology{AbstractBandset}}; kwargs...)\n\nVisualize a satellite image after applying a histogram stretch. Returns either an RGB or grayscale image compatible with the Images.jl ecosystem.\n\nA number of band combinations are supported for types implementing the AbstractBandSet interface.\n\nExample 1\n\nlandsat = read(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")\nimg = mndwi(landsat, Landsat8) |> visualize\nsave(\"mndwi.png\", img)\n\nExample 2\n\nlandsat = read(Landsat8, \"LC08_L2SP_043024_20200802_20200914_02_T1/\")\nimg = visualize(landsat, TrueColor{Landsat8}; upper=0.90)\nsave(\"truecolor.png\", img)\n\n\n\n\n\n","category":"method"},{"location":"#Preprocessing","page":"Home","title":"Preprocessing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"preprocessing.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.create_tiles-Tuple{Any, Tuple{Int64, Int64}}","page":"Home","title":"RemoteSensingToolbox.create_tiles","text":"create_tiles(raster, tile::Tuple{Int,Int}; stride=tile)\n\nSlice the given raster into tiles with size tile.\n\nParameters\n\nraster: The raster to be cut into tiles.\ntile: The size of the generated tiles in terms of width x height.\nstride: The distance between the top-left corner of each tile. Is equal to tile by default, which produces non-overlapping tiles.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.mask_pixels!-Tuple{Rasters.AbstractRaster, Any}","page":"Home","title":"RemoteSensingToolbox.mask_pixels!","text":"mask_pixels!(raster, mask; invert_mask=false)\n\nDrop pixels from a raster according to a given mask. The mask and raster must have the same extent and size.\n\nParameters\n\nraster: The raster to be masked.\nmask: A mask defining which pixels we want to drop. By default, we drop pixels corresponding to mask values of 1.\ninvert_mask: Treat mask values of 1 as 0 and vice-versa.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.mask_pixels-Tuple{Rasters.AbstractRaster, Any}","page":"Home","title":"RemoteSensingToolbox.mask_pixels","text":"mask_pixels(raster, mask; invert_mask=false)\n\nDrop pixels from a raster according to a given mask. The mask and raster must have the same extent and size.\n\nParameters\n\nraster: The raster to be masked.\nmask: A mask defining which pixels we want to drop. By default, we drop pixels corresponding to mask values of 1.\ninvert_mask: Treat mask values of 1 as 0 and vice-versa.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.tocube-Tuple{Rasters.RasterStack}","page":"Home","title":"RemoteSensingToolbox.tocube","text":"tocube(rs::RasterStack; layers=names(rs))\ntocube(rs::AbstractBandset; layers=names(rs))\n\nTransform the multi-layer RasterStack to a multi-band raster.\n\nParameters\n\nX: The RasterStack or AbstractBandset to be transformed into a multi-band raster.\nlayers: The layers to include in the new raster.\n\nExample\n\njulia> landsat = Landsat8(\"LC08_L2SP_043024_20200802_20200914_02_T1\");\njulia> tocube(landsat)\n7821×7921×7 Raster{Float32,3} B1 with dimensions: \n  X Projected{Float64} LinRange{Float64}(493785.0, 728385.0, 7821) ForwardOrdered Regular Points crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(5.84638e6, 5.60878e6, 7921) ReverseOrdered Regular Points crs: WellKnownText,\n  Band Categorical{Int64} 1:7 ForwardOrdered\nextent: Extent(X = (493785.0, 728385.0), Y = (5.608785e6, 5.846385e6), Band = (1, 7))\nmissingval: 0.0f0\ncrs: PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]\nparent:\n[:, :, 1]\n           5.84638e6  5.84636e6  5.84632e6  5.8463e6  5.84626e6  …  5.60894e6  5.6089e6  5.60888e6  5.60884e6  5.60882e6  5.60878e6\n 493785.0  0.0        0.0        0.0        0.0       0.0           0.0        0.0       0.0        0.0        0.0        0.0\n      ⋮                                               ⋮          ⋱                                             ⋮          \n 728355.0  0.0        0.0        0.0        0.0       0.0           0.0        0.0       0.0        0.0        0.0        0.0\n 728385.0  0.0        0.0        0.0        0.0       0.0           0.0        0.0       0.0        0.0        0.0        0.0\n[and 6 more slices...]\n\n\n\n\n\n","category":"method"},{"location":"#Land-Cover-Indices","page":"Home","title":"Land Cover Indices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox]\nPages = [\"indices.jl\"]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.mndwi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.mndwi","text":"mndwi(green::AbstractRaster, swir::AbstractRaster)\nmndwi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Modified Normalised Difference Water Index (Xu 2006).\n\nMNDWI = (green - swir) / (green + swir)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.nbri-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.nbri","text":"nbri(nir::AbstractRaster, swir2::AbstractRaster)\nnbri(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Normalized Burn Ratio Index.\n\nNBRI is used to emphasize burned areas.\n\nNBRI = (nir - swir2) / (nir + swir2)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndbi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndbi","text":"ndbi(swir1::AbstractRaster, nir::AbstractRaster)\nndbi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the The Normalized Difference Built-up Index\n\nNDBI is used to emphasize urban and built-up areas.\n\nNDBI = (swir1 - nir) / (swir1 + nir)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndmi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndmi","text":"ndmi(nir::AbstractRaster, swir1::AbstractRaster)\nndmi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Normalized Difference Moisture Index.\n\nNDMI is sensitive to the moisture levels in vegetation. It is used to monitor droughts and fuel levels in fire-prone areas.\n\nNDMI = (nir - swir1) / (nir + swir1)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndvi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndvi","text":"ndvi(nir::AbstractRaster, red::AbstractRaster)\nndvi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Normalized Difference Vegetation Index.\n\nNDVI = (nir - red) / (nir + red)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.ndwi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.ndwi","text":"ndwi(green::AbstractRaster, nir::AbstractRaster)\nndwi(stack::AbstractRasterStack, ::Type{AbstractBandset})\n\nCompute the Normalized Difference Water Index (McFeeters 1996).\n\nNDWI = (green - nir) / (green + nir)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.savi-Tuple{Rasters.AbstractRaster, Rasters.AbstractRaster}","page":"Home","title":"RemoteSensingToolbox.savi","text":"savi(nir::AbstractRaster, red::AbstractRaster; L=0.33)\nsavi(stack::AbstractRasterStack, ::Type{AbstractBandset}; L=0.33)\n\nCompute the Soil Adjusted Vegetation Index (Huete 1988).\n\nSAVI is a vegetation index which attempts to minimize soil brightness influences by introducing a soil-brightness correction factor (L).\n\nL represents the amount of green vegetation cover, which is set to 0.33 by default.\n\nSAVI = ((nir - red) / (nir + red + L)) * (1 + L)\n\n\n\n\n\n","category":"method"},{"location":"#Spectral-Analysis","page":"Home","title":"Spectral Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox.Spectral]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.Spectral.extract_signatures-Tuple{Rasters.AbstractRasterStack, Any, Symbol}","page":"Home","title":"RemoteSensingToolbox.Spectral.extract_signatures","text":"extract_signatures(stack::AbstractRasterStack, shp, label::Symbol; label_name=nothing)\n\nExtract signatures from the given RasterStack or AbstractSensor within regions specified by a given shapefile.\n\nParameters\n\nstack: The RasterStack from which to extract spectral signatures.\nshp: A Tables.jl compatible object containing a :geometry column storing a GeoInterface.jl compatible geometry and a label column indicating the land cover type.\nlabel: The column in shp in which the land cover class is stored.\n\nReturns\n\nA DataFrame consisting of rows for each extracted signature and columns storing the respective bands and land cover type.\n\nExample\n\njulia> landsat = @pipe read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)\n\njulia> shp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame\n\njulia> extract_signatures(landsat, shp, :C_name)\n1925×8 DataFrame\n  Row │ B1         B2         B3        B4        B5        B6        B7        label     \n      │ Float32    Float32    Float32   Float32   Float32   Float32   Float32   String    \n──────┼───────────────────────────────────────────────────────────────────────────────────\n    1 │ 0.057235   0.10547    0.188932  0.24847   0.513405  0.315323  0.166107  Hail Scar\n    2 │ 0.0574     0.105415   0.188712  0.24946   0.513735  0.317908  0.167593  Hail Scar\n    3 │ 0.0584175  0.107175   0.19182   0.253887  0.515577  0.319585  0.168087  Hail Scar\n    4 │ 0.0583625  0.10723    0.190995  0.253393  0.514615  0.317715  0.167097  Hail Scar\n    5 │ 0.05806    0.10745    0.189895  0.250368  0.50774   0.315048  0.165475  Hail Scar\n  ⋮   │     ⋮          ⋮         ⋮         ⋮         ⋮         ⋮         ⋮          ⋮\n 1921 │ 0.077145   0.112097   0.17081   0.19677   0.25705   0.320877  0.28015   Built Up\n 1922 │ 0.10712    0.136765   0.19666   0.225068  0.268655  0.33284   0.302288  Built Up\n 1923 │ 0.0856425  0.123235   0.185853  0.211675  0.273     0.373623  0.351072  Built Up\n 1924 │ 0.088145   0.119578   0.17059   0.204442  0.27487   0.355857  0.325553  Built Up\n 1925 │ 0.0518725  0.0816275  0.148673  0.15189   0.28774   0.309218  0.29786   Built Up\n                                                                         1915 rows omitted\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.Spectral.plot_signatures!-Tuple{Any, Type{<:AbstractBandset}, DataFrames.DataFrame}","page":"Home","title":"RemoteSensingToolbox.Spectral.plot_signatures!","text":"plot_signatures!(ax, bandset::Type{<:AbstractBandset}, sigs::DataFrame; label=:label, colors=wong_colors())\n\nPlot spectral signatures for each land cover type specified in a given shapefile by mutating a Makie.Axis object.\n\nAccepts the same keywords as Makie.lines!.\n\nParameters\n\nax: The Makie.Axis into which we want to draw our plot.\nbandset: The sensor type to which the signatures belong.\nsigs: A DataFrame of signatures with columns corresponding to bands and labels.\nlabel: The column of sigs in which the land cover type is stored (default = :label).\ncolors: The color scheme used by the plot.\n\nExample\n\n# Read Images And Convert DNs To Reflectance\nlandsat = @pipe read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)\nsentinel = @pipe read_bands(Sentinel2, \"data/T11UPT_20200804T183919/R60m/\") |> dn_to_reflectance(Sentinel2, _)\n\n# Load Shapefile\nshp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame\n\n# Extract Signatures\nlandsat_sigs = extract_signatures(landsat, shp, :MC_name) |> summarize_signatures\nsentinel_sigs = extract_signatures(sentinel, shp, :MC_name) |> summarize_signatures\n\n# Create Axes\nfig = Figure();\nax1 = Axis(fig[1,1], xlabel=\"Wavelength (nm)\", ylabel=\"Reflectance\", title=\"Landsat Signatures\");\nax2 = Axis(fig[2,1], xlabel=\"Wavelength (nm)\", ylabel=\"Reflectance\", title=\"Sentinel Signatures\");\n\n# Plot Signatures\nplot_signatures!(ax1, Landsat8, landsat_sigs; colors=cgrad(:tab10))\nplot_signatures!(ax2, Sentinel2, sentinel_sigs; colors=cgrad(:tab10))\n\n# Add Legend\nLegend(fig[:,2], ax1)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.Spectral.plot_signatures-Tuple{Type{<:AbstractBandset}, DataFrames.DataFrame}","page":"Home","title":"RemoteSensingToolbox.Spectral.plot_signatures","text":"plot_signatures(bandset::Type{<:AbstractBandset}, sigs::DataFrame; label=:label, colors=wong_colors())\n\nPlot the spectral signatures for one or more land cover types.\n\nParameters\n\nbandset: The sensor type to which the signatures belong.\nsigs: A DataFrame of signatures with columns corresponding to bands and labels.\nlabel: The column of sigs in which the land cover type is stored (default = :label).\ncolors: The color scheme used by the plot.\n\nExample\n\n# Read Landsat And Convert DNs To Reflectance\nlandsat = @pipe read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)\n\n# Load Shapefile\nshp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame\n\n# Extract Signatures\nsigs = extract_signatures(landsat, shp, :C_name) |> summarize_signatures\n\n# Plot Signatures\nplot_signatures(Landsat8, sigs)\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.Spectral.summarize_signatures","page":"Home","title":"RemoteSensingToolbox.Spectral.summarize_signatures","text":"summarize_signatures([reducer], sigs::DataFrame, [label])\n\nSummarize a collection of spectral signatures by grouping according to their land cover type, then reducing each group to a single summary statistic.\n\nParameters\n\nreducer: A function that reduces a collection of values to a single statistic (defaults to mean).\nsigs: A DataFrame of signatures, where each row contains the band measurements for a single pixel and the corresponding land cover type.\nlabel: The column in sigs which stores the land cover type (default is :label).\n\nReturns\n\nA DataFrame consisting of rows for each land cover type's summarized signature.\n\nExample\n\njulia> landsat = @pipe read_bands(Landsat8, \"data/LC08_L2SP_043024_20200802_20200914_02_T1/\") |> dn_to_reflectance(Landsat8, _)\n\njulia> shp = Shapefile.Table(\"data/landcover/landcover.shp\") |> DataFrame\n\njulia> sigs = extract_signatures(landsat, shp, :C_name)\n\njulia> summarize_signatures(sigs, :label)\n7×8 DataFrame\n Row │ label       B1           B2          B3         B4          B5        B6          B7         \n     │ String      Float32      Float32     Float32    Float32     Float32   Float32     Float32    \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Hail Scar   0.0617346    0.107954    0.188092   0.247114    0.508847  0.322815    0.173574\n   2 │ Bare Earth  0.0483927    0.0539072   0.0773476  0.0883738   0.231219  0.307681    0.199805\n   3 │ Road        0.0396956    0.0530674   0.0933762  0.0952315   0.245672  0.205506    0.142639\n   4 │ Lake        0.000517442  0.00360272  0.0132789  0.00628491  0.031176  0.00697667  0.00377249\n   5 │ Trees       0.0182846    0.0204864   0.0404257  0.0245542   0.319328  0.139772    0.0585171\n   6 │ Vegetation  0.00442494   0.015797    0.0789011  0.0464686   0.49601   0.0964562   0.0407997\n   7 │ Built Up    0.0892711    0.118764    0.177746   0.200785    0.293111  0.33917     0.304133\n\n\n\n\n\n","category":"function"},{"location":"#Transformations","page":"Home","title":"Transformations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RemoteSensingToolbox.Transformations]\nPrivate = false","category":"page"},{"location":"#RemoteSensingToolbox.Transformations.AbstractTransformation","page":"Home","title":"RemoteSensingToolbox.Transformations.AbstractTransformation","text":"The supertype of all transformations. Subtypes are expected to implement the fit and transform methods.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Transformations.Normalize","page":"Home","title":"RemoteSensingToolbox.Transformations.Normalize","text":"A struct for storing the parameters necessary to perform a normalization transformation.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Transformations.PCA","page":"Home","title":"RemoteSensingToolbox.Transformations.PCA","text":"A struct for storing the parameters necessary to perform a PCA transformation.\n\n\n\n\n\n","category":"type"},{"location":"#RemoteSensingToolbox.Transformations.fit_transform-Union{Tuple{T}, Tuple{Type{T}, Any}} where T<:AbstractTransformation","page":"Home","title":"RemoteSensingToolbox.Transformations.fit_transform","text":"fit_transform(transformation::Type{AbstractTransformation}, raster; kwargs...)\nfit_transform(transformation::Type{Normalize}, raster)\nfit_transform(transformation::Type{PCA}, raster; components=nbands(raster), method=:cov, stats_fraction=1.0)\n\nFit the specified transformation to the given AbstractRasterStack or AbstractRaster.\n\nParameters\n\ntransformation: The transformation we want to fit.\nraster: The AbstractRaster or AbstractRasterStack on which to fit the specified transformation.\n\nSupported Transformations\n\nNormalize: Scales and shifts the data so that each band has a mean of 0 and a standard deviation of 1.\nPCA: Rotates each pixel into a new orthogonal color-space, which may have fewer dimensions than the original.\n\nPCA Parameters\n\ncomponents: The number of principal components to use.\nmethod: One of either :cov or :cor, depending on whether we want to run PCA on the covariance or the correlation matrix.\nstats_fraction: The fraction of pixels to use in the calculation. Setting stats_fraction < 1 will produce faster but less accurate results. \n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.Transformations.inverse_transform-Union{Tuple{T}, Tuple{T, Any, Vararg{Any}}} where T<:AbstractTransformation","page":"Home","title":"RemoteSensingToolbox.Transformations.inverse_transform","text":"inverse_transform(transformation::AbstractTransformation, raster)\ninverse_transform(transformation::Normalize, raster; output_type=Float32)\ninverse_transform(transformation::PCA, raster; output_type=Float32)\n\nUndo a previously applied transformation.\n\nParameters\n\ntransformation: Some previously applied transformation that we want to reverse.\nraster: A previously transformed AbstractRaster or AbstractRasterStack from which we want to recover the original.\n\nSupported Transformations\n\nNormalize: Scales and shifts the data so that each band has a mean of 0 and a standard deviation of 1.\nPCA: Rotates each pixel into a new orthogonal color-space, which may have fewer dimensions than the original.\n\nNormalize Parameters\n\noutput_type: The element type for the restored raster. Rounds to the nearest integer if an Integer type is given.\n\nPCA Parameters\n\noutput_type: The element type for the restored raster. Rounds to the nearest integer if an Integer type is given.\n\n\n\n\n\n","category":"method"},{"location":"#RemoteSensingToolbox.Transformations.transform-Union{Tuple{T}, Tuple{T, Any}} where T<:AbstractTransformation","page":"Home","title":"RemoteSensingToolbox.Transformations.transform","text":"transform(transformation::AbstractTransformation, raster; kwargs...)\ntransform(transformation::Normalize, raster)\ntransform(transformation::PCA, raster; output_type=Float32)\n\nPerforms the fitted transformation to the provided AbstractRaster or AbstractRasterStack.\n\nParameters\n\ntransformation: The transformation we want to apply.\nraster: The AbstractRaster or AbstractRasterStack on which to perform the given transformation.\n\nSupported Transformations\n\nNormalize: Scales and shifts the data so that each band has a mean of 0 and a standard deviation of 1.\nPCA: Rotates each pixel into a new orthogonal color-space, which may have fewer dimensions than the original.\n\nNormalize Parameters\n\noutput_type: The element type for the transformed raster. Rounds to the nearest integer if an Integer type is given.\n\nPCA Parameters\n\noutput_type: The element type for the transformed raster. Rounds to the nearest integer if an Integer type is given.\n\n\n\n\n\n","category":"method"}]
}
